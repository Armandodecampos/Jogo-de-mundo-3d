
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Small World</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Incluir Font Awesome para o ícone de engrenagem e mão (machado e martelo serão imagens) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body { /* Remove default body margins and set font */
            margin: 0;
            overflow: hidden;
            font-family: "Inter", sans-serif;
             -webkit-user-select: none; /* Safari */
    -moz-user-select: none; /* Firefox */
    -ms-user-select: none; /* Internet Explorer/Edge */
    user-select: none; /* Padrão */
        }
        canvas { /* Ensure canvas takes full available space and is a block element */
            display: block;
            cursor: none; /* Oculta o cursor apenas no canvas do jogo por padrão */
        }
        /* #messageBox foi removido */
        #crosshair { /* Style for the crosshair in the center of the screen */
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px; /* Crosshair width */
            height: 20px; /* Crosshair height */
            transform: translate(-50%, -50%); /* Perfectly center the crosshair */
            pointer-events: none; /* Allow clicks to pass through the crosshair */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999; /* Ensure it's above the canvas, but below the messageBox */
        }
        #crosshair::before, #crosshair::after { /* Create crosshair lines */
            content: '';
            position: absolute;
            background-color: var(--crosshair-color, white); /* Default crosshair color, uses CSS variable */
            transition: background-color 0.1s ease-in-out; /* Smooth color transition */
        }
        #crosshair::before { /* Horizontal line */
            width: 100%;
            height: 2px;
        }
        #crosshair::after { /* Vertical line */
            width: 2px;
            height: 100%;
        }

        /* Start Screen Styles */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            color: white;
            text-align: center;
        }
        #startScreen h1 {
            font-size: 3em;
            margin-bottom: 20px;
            /* Prevent text selection for the title */
            -webkit-touch-callout: none; /* iOS Safari */
            -webkit-user-select: none;   /* Safari */
            -khtml-user-select: none;    /* Konqueror HTML */
            -moz-user-select: none;      /* Old versions of Firefox */
            -ms-user-select: none;       /* Internet Explorer/Edge */
            user-select: none;           /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
        }
        #startButton {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1.5em;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #startButton:hover {
            background-color: #45a049;
        }

        /* Options Screen Styles */
        #optionsScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Darker overlay */
            display: flex; /* Mantém flex para centralização, mas controla visibilidade com classe */
            visibility: hidden; /* Hidden by default */
            opacity: 0; /* Also hidden by default for smooth transition */
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; /* Smooth fade in/out */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1002; /* Above start screen */
            color: white;
            text-align: center;
        }
        #optionsScreen.active { /* Class to activate the menu */
            visibility: visible;
            opacity: 1;
        }
        #optionsScreen h2 {
            font-size: 2.5em;
            margin-bottom: 30px;
        }
        #optionsScreen button {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1.2em;
            cursor: pointer;
            margin: 10px;
            transition: background-color 0.3s ease;
        }
        #optionsScreen button:hover {
            background-color: #45a049;
        }
        #exitGameButton { /* Specific style for exit button */
            background-color: #dc3545; /* Red for exit */
        }
        #exitGameButton:hover {
            background-color: #c82333;
        }

        /* Inventory Belt Styles */
        #inventoryBelt {
            position: absolute;
            left: 50%; /* Centraliza horizontalmente */
            bottom: 20px; /* Distância da parte inferior */
            transform: translateX(-50%); /* Ajusta para centralizar com base na própria largura */
            display: flex;
            flex-direction: row; /* Alinha os itens horizontalmente */
            align-items: center; /* Centraliza itens verticalmente dentro da linha */
            gap: 8px; /* Espaço entre slots e botão */
            background-color: rgba(0, 0, 0, 0.9); /* Fundo semi-transparente */
            padding: 10px;
            border-radius: 10px;
            z-index: 998;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .slot {
            width: 100px;
            height: 100px;
            border: 2px solid #555;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column; /* Para empilhar ícone e quantidade */
            justify-content: center;
            align-items: center;
            color: #bbb;
            font-size: 0.9em;
            transition: border-color 0.1s ease-in-out, background-color 0.1s ease-in-out;
            position: relative; /* Para posicionar a quantidade */
            cursor: grab; /* Cursor para indicar que é arrastável */
        }
        .slot.selected { /* Estilo para o slot selecionado */
            border-color: #4CAF50; /* Borda verde */
            box-shadow: 0 0 0 3px #4CAF50; /* Sombra verde */
        }

        .slot-quantity {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.7em;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        .slot-icon {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Garante que a imagem se ajuste ao slot */
            padding: 5px; /* Adiciona um pequeno preenchimento */
            border-radius: 50%;
        }
        .slot-key-bind { /* Estilo para as letras de atalho (Q, E) */
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 0.7em;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            font-weight: bold;
        }

        /* Backpack Button */
        #backpackButton {
            background-color: #8B4513; /* Brown color */
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #backpackButton:hover {
            background-color: #6B350F;
        }

        /* Backpack Modal */
        #backpackModal {
            position: absolute;
            top: 50%; /* Center vertically */
            left: 50%;
            transform: translate(-50%, -50%); /* Center horizontally and vertically */
            background-color: rgba(50, 50, 50, 0.9);
            border: 2px solid #777;
            border-radius: 10px;
            padding: 20px;
            z-index: 1000;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            width: 80%; /* Adjust as needed */
            max-width: 600px; /* Max width for larger screens */
            max-height: 60%; /* Max height for larger screens */
            overflow-y: auto; /* Enable scrolling if content overflows */
        }
        #backpackModal.active {
            display: flex;
        }
        #backpackModal h2 {
            color: white;
            font-size: 2em;
            margin-bottom: 20px;
        }
        #backpackSlotsContainer {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); /* Responsive grid */
            gap: 8px;
            width: 100%;
            max-width: 500px; /* Max width for the grid itself */
            margin-bottom: 20px;
        }
        #backpackModal .slot {
            width: 60px;
            height: 60px;
            border: 2px solid #555;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #bbb;
            font-size: 0.9em;
            position: relative;
            cursor: grab;
        }
        #backpackModal .slot.drag-over {
            border-color: #4CAF50; /* Green border when dragging over */
        }

        #backpackModal .close-button {
            background-color: #dc3545;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            align-self: flex-end; /* Align to the right */
            margin-top: -10px; /* Pull it up slightly */
        }
        #backpackModal .close-button:hover {
            background-color: #c82333;
        }

        /* Dragging ghost element style */
        .dragging-ghost {
            position: absolute;
            pointer-events: none; /* Crucial to allow events to pass through to elements below */
            z-index: 10000; /* Ensure it's on top of everything */
            opacity: 0.7;
            width: 60px; /* Same size as a slot */
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px dashed #FFF;
            border-radius: 50%;
        }

        #progressContainer {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
            z-index: 1000;
            display: none; /* Inicia oculto */
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>Small World</h1>
        <button id="startButton">Jogar</button>
    </div>

    <!-- Novo botão de menu no canto superior esquerdo -->
    <button id="menuIconButton" class="absolute top-4 left-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg flex items-center space-x-2 z-1000 hidden">
        <i class="fas fa-cog"></i> <!-- Ícone de engrenagem -->
        <span>Esc</span>
    </button>

    <div id="optionsScreen">
        <h2>Opções do Jogo</h2>
        <button id="resumeButton">Voltar ao Jogo</button>
        <button id="exitGameButton">Sair do Jogo</button>
    </div>

    <div id="progressContainer">
        <div id="progressBar"></div>
    </div>

    <div id="crosshair"></div>

    <!-- #messageBox foi removido -->

    <!-- Inventory Belt HTML Structure -->
    <div id="inventoryBelt">
        <!-- Slots e botão da mochila serão preenchidos dinamicamente pelo JavaScript -->
    </div>

    <!-- Backpack Modal -->
    <div id="backpackModal">
        <button class="close-button" id="closeBackpackButton">X</button>
        <h2>Mochila</h2>
        <div id="backpackSlotsContainer">
            <!-- Backpack slots will be dynamically filled by JavaScript -->
        </div>
    </div>

    <script type="module">
        // Importa as bibliotecas Three.js e Cannon-es de CDNs
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js';

        // Variáveis globais para cena, câmera, renderizador e mundo da física
        let scene, camera, renderer, world;
        let skyFog, underwaterFog; // NOVO: Para o efeito subaquático
        let skyColor, underwaterColor; // NOVO: Para as cores do ambiente
        // Variáveis para corpos e malhas de jogador, terreno (rua), estrada e cubo
        let playerBody;
        let islandBody; // Corpo de física para o terreno (agora uma ilha)
        let islandMeshes = []; // Array para armazenar múltiplas malhas visuais da ilha

        let waterMeshes = []; // NOVO: Array para armazenar múltiplas malhas visuais da água
        let seabedMeshes = []; // NOVO: Array para armazenar múltiplas malhas visuais do fundo do mar

        // NOVO: Array para rastrear todas as caixas colecionáveis (corpos e malhas)
        let collectibleBoxes = [];

        // Variáveis para blocos de construção colocáveis pelo jogador (tijolos e pisos)
        let placedConstructionBodies = []; // Corpos de blocos colocados pelo jogador
        let placedConstructionMeshesArrays = []; // Malhas de blocos colocados pelo jogador
        let visualOffsetX = 0;
        let visualOffsetZ = 0;

        // Objeto para rastrear as teclas pressionadas
        let keysPressed = {};
        // Variáveis para controle do mouse (rotação da câmera)
        let isDragging = false;

        // Variáveis para funcionalidade de seleção e movimentação de objetos
        let raycaster;
        let pickedObjectBody = null;
        let pickedObjectMesh = null; // Referência à malha visual específica que está sendo selecionada
        let grabberBody = null;
        let grabberConstraint = null;
        let distanceToPickedObject = 5; // Declarada globalmente para resolver o ReferenceError
        const pickUpDistance = 3.0; // Distância máxima para pegar um objeto
        const destroyDistance = 5.0; // Distância máxima para destruir um objeto

        // NOVO: Variáveis para o sistema de destruição progressiva
        let isDestroying = false;
        let destroyProgress = 0;
        let targetDestroyTime = 0; // Tempo necessário para destruir o objeto (em segundos)
        let destroyTargetBody = null; // Corpo que está sendo destruído
        let destroyTargetMesh = null; // Malha visual do corpo
        let destroyTargetPatchObject = null;
        let destroyTargetDeposit = null; // Para rastrear o depósito alvo
        let destructionComplete = false; // NOVO: Flag para gerenciar o estado de destruição

        // NOVO: Variáveis para a lógica de clique vs. segurar
        let mouseDownTime = 0;
        let clickHoldTimer = null;
        const CLICK_HOLD_DURATION = 250; // ms

        // Altura da câmera em relação ao centro do corpo do jogador (nível dos olhos)
        let cameraEyeLevelOffset; // Alterado para 'let' pois será modificado
        let originalCameraEyeLevelOffset; // Para armazenar o valor inicial

        // Variável para controlar se o personagem pode pular
        let canJump = true;
        let isWaterJumping = false; // NOVO: Para controlar o salto a partir da água

        // Variáveis globais para dimensões do jogador e vetor de direção horizontal
        // A altura do personagem será o diâmetro da esfera
        const playerBodyHeight = 1.74;
        const playerRadius = playerBodyHeight / 2; // Raio da esfera (metade da altura)

        // Novo: Define as dimensões de agachamento
        const crouchHeightReduction = 0.8; // O quanto a câmera e o corpo abaixam ao agachar
        const crouchBodyHeight = playerBodyHeight - crouchHeightReduction; // Calcula a nova altura
        const crouchRadius = crouchBodyHeight / 2;   // Raio da esfera agachada

        let originalPlayerShape; // Para armazenar a forma inicial
        let crouchPlayerShape;   // Para armazenar a forma agachada

        // Define as dimensões do mundo para X e Z (para efeito de envolvimento)
        const worldSize = 1200;
        const islandRadiusTop = 300; // NOVO: Raio do topo da ilha
        const islandRadiusBottom = 600; // NOVO: Raio da base da ilha
        const waterLevel = -9.6; // NOVO: Nível da água
        const seabedLevel = -20; // NOVO: Nível do fundo do mar
        const renderDistance = 200; // Distância de renderização para objetos
        // NOVO: A altura do terreno e a altura dos blocos de cob são agora as mesmas.
        const cobSize = 0.4;
        const islandSurfaceHeight = 0.8; // A altura da superfície visível da ilha

        // NOVO: Constantes e variáveis para depósitos de terra
        const dirtDepositTextureURL = "https://dl.dropbox.com/scl/fi/42sa7tz724dwunu8imycm/textura-de-terra-2.png?rlkey=7hibzddcn7cco8jeolqada3ho&st=2hknz00t&dl=0";
        let dirtDepositMaterial;
        let flattenedDirtDepositMaterial; // Material para o estado achatado
        const numDirtDeposits = 40;
        const dirtDepositRadius = 3; // Isso agora servirá como um raio *base*
        const dirtDepositHeight = 2; // Isso agora servirá como uma altura *base*
        let dirtDeposits = []; // Array para rastrear o estado e os objetos de cada depósito
        const islandHeight = islandSurfaceHeight - seabedLevel; // Altura total do cilindro da ilha
        const roadWidth = 10; // Largura da estrada
        const roadHeight = 0.2; // Espessura da estrada
        const numTiles = 3; // Para uma grade 3x3 de tiles visíveis (e cubos)

        // Velocidades de movimento
        const walkSpeed = 5; // Velocidade base de caminhada
        const runSpeedMultiplier = 2; // Multiplicador para velocidade de corrida

        // Variáveis de agachamento
        let isCrouching = false;
        const crouchSpeedMultiplier = 0.5; // Multiplicador para velocidade ao agachar

        // Variável global para luz direcional
        let directionalLight;
        let ambientLight;

        // Referência ao elemento da mira
        let crosshairElement;

        // Referências aos elementos da barra de progresso
        let progressContainer;
        let progressBar;

        // Variáveis de estado do jogo
        let gamePaused = false; // Novo: Flag para pausar/retomar a lógica do jogo
        let pointerLockExitForBackpack = false; // NOVO: Flag para controlar a saída do pointer lock devido à mochila

        // NOVO: Gerenciador de carregamento para rastrear quando todos os recursos são carregados
        let isWorldReady = false;
        const loadingManager = new THREE.LoadingManager();
        loadingManager.onLoad = () => {
            console.log("Todos os recursos carregados, o mundo está pronto.");
            isWorldReady = true;
        };

        // Instância do carregador de textura, agora usando o gerenciador de carregamento
        const textureLoader = new THREE.TextureLoader(loadingManager);

        // Referência ao botão de ícone do menu
        let menuIconButton;

        // Variáveis para o cinto de inventário
        let inventoryBeltElement;
        let slots = []; // Array para armazenar os elementos dos slots
        const numBeltSlots = 2; // Número total de slots do cinto (apenas 2 agora)
        let selectedSlotIndex = 0; // NOVO: Índice do slot selecionado (0 para esquerdo, 1 para direito)

        // Variáveis para o sistema de mochila
        let backpackModal;
        let backpackSlotsContainer;
        const numBackpackSlots = 50;

        // Inventário (agora separado para cinto e mochila)
        let beltItems = new Array(numBeltSlots).fill(null);
        let backpackItems = new Array(numBackpackSlots).fill(null);

        // Drag and drop variables
        let isDraggingItem = false;
        let draggedItem = null; // { item: { name, quantity }, sourceLocation: 'belt' | 'backpack', sourceIndex: number }
        let draggingGhostElement = null;

        // NOVO: Variáveis para o sistema de agarrar objetos (Mão)
        const handItemName = 'mao'; // Nome do item de mão no inventário

        // NOVO: Variáveis para o sistema de destruição de blocos (Machado e Martelo)
        const axeItemName = 'machado'; // Nome do item de machado no inventário
        const hammerItemName = 'martelo'; // Nome do item de martelo no inventário
        const stoneItemName = 'pedra'; // NOVO: Nome do item de pedra no inventário
        const dirtItemName = 'terra'; // NOVO: Nome do item de terra no inventário
        const shovelItemName = 'pá'; // NOVO: Nome do item de pá no inventário
        const textureApplicatorItemName = 'pincel'; // FERRAMENTA RENOMEADA

        // NOVO: Variáveis para o sistema de colocação de blocos (Cob, Piso, Muda de Árvore, Tronco de Árvore, Tábuas)
        const cobItemName = 'cob'; // Nome do item de cob no inventário
        const floorItemName = 'piso'; // Nome do item de piso no inventário
        const treeSaplingItemName = 'muda_arvore'; // Nome do item de muda de árvore no inventário
        const treeTrunkItemName = 'tronco_arvore'; // NOVO: Nome do item de tronco de árvore
        const woodenPlankItemName = 'tábuas'; // NOVO: Nome do item de tábuas de madeira
        const boxItemName = 'caixote'; // NOVO: Nome do item de caixote

        let ghostBlockMesh; // Malha transparente para pré-visualizar a colocação
        let currentBlockType = 'cob'; // 'cob' ou 'piso'
        let ghostBlockRotationY = 0; // Novo: Armazena a rotação horizontal manual do bloco fantasma
        let ghostBlockRotationX = 0; // Novo: Armazena a rotação vertical manual do bloco fantasma

        // Dimensões do cob
        const cobWidth = cobSize;
        const cobHeight = cobSize;
        const cobDepth = cobSize;
        const initialCobMass = 50; // Massa para os cobs
        const cobDurability = 0.75; // Durabilidade do cob em segundos

        // Dimensões do piso
        const floorWidth = cobWidth; // Largura do piso (now equal to cob)
        const floorHeight = 0.1; // Altura reduzida do piso
        const floorDepth = cobSize; // Profundidade do piso (now equal to cob)
        const initialFloorMass = 100; // Massa para os pisos
        const floorDurability = 1.0; // Durabilidade do piso em segundos

        // Dimensões da tábua de madeira
        const woodenPlankWidth = cobWidth;
        const woodenPlankHeight = 0.1;
        const woodenPlankDepth = cobSize;
        const initialWoodenPlankMass = 50;
        const woodenPlankDurability = 0.5; // Durabilidade da tábua em segundos

        // Dimensões da muda de árvore
        const initialTreeSaplingMass = 10; // Massa para as mudas de árvore (leve)
        const treeSaplingDurability = 1.5; // Durabilidade da muda em segundos

        // NOVO: Dimensões do tronco de árvore
        const trunkRadius = cobWidth / 2;
        const trunkHeight = 1.0;
        const trunkSegments = 8; // Número de segmentos para a geometria do cilindro
        const initialTrunkMass = 200; // Massa para os troncos de árvore
        const treeTrunkDurability = 2.5; // Durabilidade do tronco em segundos

        // Novo: Limiar para o efeito de "imã" (snapping)
        const snappingThreshold = 0.7; // Distância máxima para o bloco fantasma "grudar"
        // NOVO: Distância mínima para colocar árvores (para evitar sobreposição)
        const minTreePlacementDistance = 6.0; // Aumentado para 6.0 para maior espaçamento

        // URLs das texturas
        const cubeTextureURL = 'https://dl.dropbox.com/scl/fi/gj6zul0y5tl74dbyysnz8/caixote.jpg?rlkey=4v81yak0nb08mllkfh1eceijw&st=lqj60d8g&dl=0';
        const cobTextureURL = 'https://dl.dropbox.com/scl/fi/cp3ueclujrd32o6hv8d73/Cob-2.png?rlkey=5x29w33xvgol1aoxqk3p9jdkm&st=1kahc5pq&dl=0';
        const floorTextureURL = 'https://dl.dropbox.com/scl/fi/cp3ueclujrd32o6hv8d73/Cob-2.png?rlkey=5x29w33xvgol1aoxqk3p9jdkm&st=1kahc5pq&dl=0'; // Nova textura para pisos (exemplo)
        const treeSaplingTextureURL = 'https://dl.dropbox.com/scl/fi/pjdpuxo189igkd5wyvp0z/icone-de-muda-de-arvore.png?rlkey=9bvfgukhymi4qo02965pt3zl4&st=xs4n6qwo&dl=0'; // Dark green placeholder for tree icon
        const axeImageURL = 'https://dl.dropbox.com/scl/fi/6td6rpc8n54j6sz62w383/icone-de-machado.png?rlkey=zepycmnfyohef27tp7f5urnx0&st=7kbd3no2&dl=0'; // Placeholder for axe image
        const hammerImageURL = 'https://dl.dropbox.com/scl/fi/vadd8ztbnmzfqi18ml1cl/icone-de-martelo.png?rlkey=45l4k78t728fh4w4fkd4tvlef&st=cbi6paz9&dl=0'; // Placeholder for hammer image
        const stoneImageURL = 'https://placehold.co/100x100/964B00/FFFFFF?text=Pedra'; // NOVO: Imagem para a pedra
        const dirtImageURL = 'https://placehold.co/100x100/A0522D/FFFFFF?text=Terra'; // NOVO: Imagem para a terra
        const shovelImageURL = 'https://placehold.co/100x100/808080/FFFFFF?text=Pá'; // NOVO: Imagem para a pá
        const treeBarkTextureURL = 'https://dl.dropbox.com/scl/fi/lzaxw6yd9fa0rw24m8vl4/textura-tronco-arvore.jpg?rlkey=gqlaqtkubwonngvknzl7uhtbc&st=mkz0x9zj&dl=0'; // Corrected URL
        const treeLeavesTextureURL = 'https://dl.dropbox.com/s/scl/fi/gdz8f8qzmrdza0t0nntzs/textura-folhas-arvore.jpg?rlkey=efabv8qthg0fpxg1ugf7fpd3k&dl=0'; // Corrected URL
        const handImageURL = 'https://dl.dropbox.com/scl/fi/adirqfks81emnagkoljcw/m-o-direita.png?rlkey=pj17lswbeg8lene1n5ypdbmob&st=i2qtxssr&dl=0';
        const treeTrunkImageURL = 'https://dl.dropbox.com/scl/fi/lzaxw6yd9fa0rw24m8vl4/textura-tronco-arvore.jpg?rlkey=gqlaqtkubwonngvknzl7uhtbc&st=mkz0x9zj&dl=0'; // NOVO: Ícone para o tronco de árvore (placeholder)
        const woodenPlankTextureURL = 'https://dl.dropbox.com/scl/fi/0fvzfv95cncu8rnx389xj/tabua.png?rlkey=1c9vxdh6hsf8mmk0fbf7owslk&st=42utz3gy&dl=0'; // NOVO: Ícone para as tábuas
        const textureApplicatorImageURL = 'https://dl.dropbox.com/scl/fi/6uyk1vu9ttzb6jdvawhds/chao-de-pedra.png?rlkey=uqyvy2ciuk52vkhuc2davo0o9&st=c4pyo36n&dl=0'; // NOVO: Ícone para o pincel
        const stoneTextureURL = 'https://dl.dropbox.com/scl/fi/6uyk1vu9ttzb6jdvawhds/chao-de-pedra.png?rlkey=uqyvy2ciuk52vkhuc2davo0o9&st=c4pyo36n&dl=0'; // NOVO: Textura de pedra para aplicar
        const holeTextureURL = 'https://dl.dropbox.com/scl/fi/42sa7tz724dwunu8imycm/textura-de-terra-2.png?rlkey=7hibzddcn7cco8jeolqada3ho&st=tz27qsg6&dl=0'; // NOVO: Textura do buraco

        // Global variables for materials
        let cubeMaterialMesh; // NOVO: Material da caixa global
        let cobMaterialMesh;
        let floorMaterialMesh;
        let treeSaplingMaterialMesh; // New material for tree saplings icon
        let treeTrunkMaterialMesh; // Material for tree trunks (3D model)
        let treeLeavesMaterialMesh; // Material for tree leaves (3D model)
        let woodenPlankMaterialMesh; // NOVO: Material para tábuas de madeira
        let stoneMaterial; // NOVO: Material para chão com a nova textura
        let holeMaterial; // NOVO: Material para o buraco cavado

        const texturePatches = []; // NOVO: Para rastrear os remendos de aplicação de textura
        let holes = []; // NOVO: Para rastrear os buracos cavados no terreno
        let holeDomes = []; // NOVO: Para rastrear os domos visuais dos buracos
        let baseMatrix = []; // NOVO: Para armazenar a geometria base da ilha
        let splatMap; // NOVO: Máscara de textura para pintar os buracos
        let splatMapData; // NOVO: Dados brutos para a máscara de textura

        // Declare physics materials globally
        let playerMaterial;
        let islandMaterial; // Renomeado de streetMaterial
        let cubeMaterial;
        let constructionMaterial;

        // Define tree stages with base physics bounding box and visual geometry properties
        // These are base values that will be randomized for each tree instance
        const treeStages = {
            'semente': {
                physics: {
                    // A semente quase não tem corpo de física, apenas uma pequena caixa para detecção
                    trunk: { width: 0.1, height: 0.1, depth: 0.1, yOffset: 0 },
                    leaves: { width: 0, height: 0, depth: 0, yOffset: 0 } // Sem folhas
                },
                visual: {
                    // O visual da semente agora é uma esfera
                    sphere: { radius: 0.1 }
                },
                overallPhysicsHeight: 0.1,
                growthTime: 10 // Tempo em segundos para crescer para a próxima fase
            },
            'muda': {
                physics: {
                    trunk: { width: cobWidth / 2, height: 0.5, depth: cobWidth / 2, yOffset: -0.2 },
                    leaves: { width: cobWidth, height: cobWidth, depth: cobWidth, yOffset: 0.25 }
                },
                visual: {
                    trunk: { radius: cobWidth / 4, height: 0.5, yOffsetInGroup: (0.5 / 2) - (0.9 / 2) },
                    leaves: { radius: cobWidth / 2, yOffsetInGroup: (0.5 + 0.2) - (0.9 / 2) }
                },
                overallPhysicsHeight: 0.9,
                growthTime: 10 // Time in seconds to grow to next stage
            },
            'media': {
                physics: {
                    trunk: { width: cobWidth, height: 2.0, depth: cobWidth, yOffset: -0.8 },
                    leaves: { width: cobWidth * 4, height: cobWidth * 4, depth: cobWidth * 4, yOffset: 0.8 }
                },
                visual: {
                    trunk: { radius: cobWidth / 2, height: 2.0, yOffsetInGroup: (2.0 / 2) - (3.6 / 2) },
                    leaves: { radius: cobWidth * 2, yOffsetInGroup: (2.0 + 0.8) - (3.6 / 2) }
                },
                overallPhysicsHeight: 3.6, // Will be recalculated by randomizeTreeDimensions
                growthTime: 10
            },
            'arvore_adulta': {
                physics: {
                    trunk: { width: cobWidth, height: 5.0, depth: cobWidth, yOffset: -2.0 },
                    leaves: { width: cobWidth * 8, height: cobWidth * 8, depth: cobWidth * 8, yOffset: 2.0 }
                },
                visual: {
                    trunk: { radius: cobWidth / 2, height: 5.0, yOffsetInGroup: (5.0 / 2) - (9.0 / 2) },
                    leaves: { radius: cobWidth * 4, yOffsetInGroup: (5.0 + 2.0) - (9.0 / 2) }
                },
                overallPhysicsHeight: 9.0, // Will be recalculated by randomizeTreeDimensions
                growthTime: Infinity // Fully grown
            }
        };

        // Function to randomize tree dimensions based on a base stage data
        function randomizeTreeDimensions(baseStageData) {
            // Adiciona uma cláusula de guarda para o estágio 'semente', que não precisa de randomização
            if (!baseStageData.visual.trunk) {
                return JSON.parse(JSON.stringify(baseStageData)); // Retorna uma cópia profunda para segurança
            }
            const randomFactor = (min, max) => min + (Math.random() * (max - min));

            // Apply random factors (e.g., +/- 20% variation)
            const trunkHeightFactor = randomFactor(0.8, 1.2);
            const trunkRadiusFactor = randomFactor(0.8, 1.2);
            const leavesRadiusFactor = randomFactor(0.8, 1.2);

            const randomized = JSON.parse(JSON.stringify(baseStageData)); // Deep copy

            // Randomize trunk dimensions
            randomized.physics.trunk.height *= trunkHeightFactor;
            randomized.physics.trunk.width *= trunkRadiusFactor;
            randomized.physics.trunk.depth *= trunkRadiusFactor;
            randomized.visual.trunk.height *= trunkHeightFactor;
            randomized.visual.trunk.radius *= trunkRadiusFactor;

            // Randomize leaves dimensions
            randomized.physics.leaves.width *= leavesRadiusFactor;
            randomized.physics.leaves.height *= leavesRadiusFactor;
            randomized.physics.leaves.depth *= leavesRadiusFactor;
            randomized.visual.leaves.radius *= leavesRadiusFactor;

            // Recalculate yOffsets and overallPhysicsHeight based on randomized dimensions
            const trunkHeightVisual = randomized.visual.trunk.height;
            const leavesRadiusVisual = randomized.visual.leaves.radius;

            // The visual group's total height is the trunk plus the leaves' diameter.
            const groupHeightVisual = trunkHeightVisual + (leavesRadiusVisual * 2);

            // Position the trunk so its bottom aligns with the group's bottom.
            // The group is centered, so its bottom is at -groupHeight/2. The trunk's center
            // is then placed at -groupHeight/2 + trunkHeight/2.
            randomized.visual.trunk.yOffsetInGroup = (trunkHeightVisual / 2) - (groupHeightVisual / 2);

            // Position the leaves so their center is on top of the trunk's top.
            // The trunk's top is at trunk.yOffset + trunk.height/2.
            // The leaves' center should be at that position, plus their radius.
            const trunkTopY = randomized.visual.trunk.yOffsetInGroup + (trunkHeightVisual / 2);
            randomized.visual.leaves.yOffsetInGroup = trunkTopY + leavesRadiusVisual;

            // For physics, approximate the overall height for positioning
            const trunkTopPhysics = randomized.physics.trunk.height / 2;
            const leavesBottomPhysics = trunkTopPhysics;
            randomized.overallPhysicsHeight = randomized.physics.trunk.height + (randomized.physics.leaves.height); // Sum of trunk and leaves physics height

            // Adjust physics yOffsets to be relative to the new overallPhysicsHeight center
            randomized.physics.trunk.yOffset = (randomized.physics.trunk.height / 2) - (randomized.overallPhysicsHeight / 2);
            randomized.physics.leaves.yOffset = (leavesBottomPhysics + randomized.physics.leaves.height / 2) - (randomized.overallPhysicsHeight / 2);

            return randomized;
        }

        // Global array to hold active smoke particles
        let smokeParticles = [];

        // Função para mostrar a tela de opções e pausar o jogo
        function showOptionsScreen() {
            gamePaused = true;
            document.getElementById('optionsScreen').classList.add('active'); // Adiciona a classe 'active'
            document.getElementById('crosshair').style.display = 'none'; // Oculta a mira
            document.body.style.cursor = 'default'; // Mostra o cursor do corpo
            if (renderer && renderer.domElement) {
                renderer.domElement.style.cursor = 'default'; // Mostra o cursor do canvas
            }
            if (menuIconButton) {
                menuIconButton.style.display = 'none'; // Oculta o botão do menu quando o menu de opções está aberto
            }
            if (inventoryBeltElement) {
                inventoryBeltElement.style.visibility = 'hidden'; // Oculta o cinto de inventário
                inventoryBeltElement.style.opacity = '0';
            }
            // Garante que o ghost block esteja oculto ao abrir o menu
            if (ghostBlockMesh) {
                ghostBlockMesh.visible = false;
            }
            document.exitPointerLock(); // Libera o bloqueio do ponteiro
        }

        // Função para ocultar a tela de opções e retomar o jogo
        function hideOptionsScreen() {
            document.getElementById('optionsScreen').classList.remove('active'); // Remove a classe 'active'
            document.getElementById('crosshair').style.display = 'flex'; // Mostra a mira
            document.body.style.cursor = 'none'; // Esconde o cursor do corpo
            if (renderer && renderer.domElement) {
                renderer.domElement.style.cursor = 'none'; // Esconde o cursor do canvas
            }
            if (menuIconButton) {
                menuIconButton.style.display = 'flex'; // Mostra o botão do menu quando o menu de opções está fechado
            }
            if (inventoryBeltElement) {
                inventoryBeltElement.style.visibility = 'visible'; // Mostra o cinto de inventário
                inventoryBeltElement.style.opacity = '1';
            }
            // Remove a solicitação de bloqueio do ponteiro aqui. O usuário precisará clicar no canvas para reativar.
            gamePaused = false;
        }

        // Função para abrir a mochila
        function openBackpack() {
            gamePaused = true;
            backpackModal.classList.add('active');
            document.getElementById('crosshair').style.display = 'none';
            document.body.style.cursor = 'default';
            if (renderer && renderer.domElement) {
                renderer.domElement.style.cursor = 'default';
            }
            if (menuIconButton) {
                menuIconButton.style.display = 'none';
            }
            // O cinto de inventário permanece visível ao abrir a mochila
            if (inventoryBeltElement) {
                inventoryBeltElement.style.visibility = 'visible';
                inventoryBeltElement.style.opacity = '1';
            }
            if (ghostBlockMesh) {
                ghostBlockMesh.visible = false;
            }
            pointerLockExitForBackpack = true; // Define a flag antes de sair do pointer lock
            document.exitPointerLock();
            updateBackpackDisplay(); // Atualiza a exibição da mochila
        }

        // Função para fechar a mochila
        function closeBackpack() {
            backpackModal.classList.remove('active');
            gamePaused = false; // Permite que o jogo continue se o ponteiro já estiver bloqueado
            pointerLockExitForBackpack = false; // Reseta a flag ao fechar a mochila

            // Tenta reativar o pointer lock para retomar o jogo
            if (renderer && renderer.domElement) {
                renderer.domElement.requestPointerLock().catch(error => {
                    if (error.name === 'SecurityError' && error.message.includes('exited the lock')) {
                        console.warn('Solicitação de bloqueio do ponteiro falhou porque o utilizador saiu do bloqueio prematuramente.');
                    } else {
                        console.error('Erro ao solicitar bloqueio do ponteiro:', error);
                    }
                });
            }
        }

        // Função para renderizar um slot de inventário (cinto ou mochila)
        function renderSlot(item, index, containerType) {
            const slotDiv = document.createElement('div');
            slotDiv.classList.add('slot');
            slotDiv.id = `${containerType}-slot-${index}`;
            slotDiv.dataset.slotIndex = index;
            slotDiv.dataset.containerType = containerType;

            // Adiciona a classe 'selected' se este for o slot atualmente selecionado
            if (containerType === 'belt' && index === selectedSlotIndex) {
                slotDiv.classList.add('selected');
            }

            // Adiciona a letra de atalho para os slots do cinto (SEMPRE para slots do cinto)
            if (containerType === 'belt') {
                const keyBindSpan = document.createElement('span');
                keyBindSpan.classList.add('slot-key-bind');
                keyBindSpan.textContent = (index === 0) ? 'Q' : 'E';
                slotDiv.appendChild(keyBindSpan);
            }

            if (item) {
                const img = document.createElement('img');
                const quantitySpan = document.createElement('span');

                // Define o ícone com base no nome do item
                if (item.name === axeItemName) {
                    img.src = axeImageURL;
                } else if (item.name === hammerItemName) {
                    img.src = hammerImageURL;
                } else if (item.name === stoneItemName) { // NOVO
                    img.src = stoneImageURL;
                } else if (item.name === dirtItemName) { // NOVO
                    img.src = dirtImageURL;
                } else if (item.name === shovelItemName) { // NOVO
                    img.src = shovelImageURL;
                } else if (item.name === textureApplicatorItemName) {
                    img.src = textureApplicatorImageURL;
                } else if (item.name === cobItemName) {
                    img.src = cobTextureURL;
                } else if (item.name === floorItemName) {
                    img.src = floorTextureURL;
                } else if (item.name === treeSaplingItemName) {
                    img.src = treeSaplingTextureURL;
                } else if (item.name === treeTrunkItemName) { // Ícone para tronco de árvore
                    img.src = treeTrunkImageURL;
                } else if (item.name === woodenPlankItemName) { // Ícone para tábuas de madeira
                    img.src = woodenPlankTextureURL;
                } else if (item.name === boxItemName) {
                    img.src = cubeTextureURL;
                }
                img.classList.add('slot-icon');
                slotDiv.appendChild(img);

                if (item.quantity > 1) { // Só mostra a quantidade se for maior que 1
                    quantitySpan.classList.add('slot-quantity');
                    quantitySpan.textContent = item.quantity;
                    slotDiv.appendChild(quantitySpan);
                }
            } else if (containerType === 'belt') {
                const img = document.createElement('img');
                img.src = handImageURL;
                img.classList.add('slot-icon');
                // Inverte a imagem horizontalmente se estiver no slot esquerdo (índice 0)
                if (index === 0) {
                    img.style.transform = 'scaleX(-1)';
                }
                slotDiv.appendChild(img);
            }

            // Adiciona listeners para drag and drop APENAS se o slot não for a "mão" (ou seja, se tiver um item)
            // ou se for um slot da mochila (que pode ser vazio, mas não representa a "mão")
            if (!(containerType === 'belt' && item === null)) {
                slotDiv.addEventListener('mousedown', (e) => startDrag(e, item, index, containerType));
                slotDiv.addEventListener('mouseenter', (e) => {
                    if (isDraggingItem) {
                        e.currentTarget.classList.add('drag-over');
                    }
                });
                slotDiv.addEventListener('mouseleave', (e) => {
                    e.currentTarget.classList.remove('drag-over');
                });
            }

            return slotDiv;
        }

        // Helper function to add item to inventory (belt or backpack)
        function addItemToInventory(inventoryArray, itemToAdd) {
            // Try to stack first
            for (let i = 0; i < inventoryArray.length; i++) {
                // Skip the hand slot (beltItems[0]) when trying to stack or find empty slot
                if (inventoryArray === beltItems && i === 0) continue;

                if (inventoryArray[i] && inventoryArray[i].name === itemToAdd.name) {
                    inventoryArray[i].quantity += itemToAdd.quantity;
                    return; // Item stacked
                }
            }
            // If not stacked, find an empty slot
            for (let i = 0; i < inventoryArray.length; i++) {
                // Skip the hand slot (beltItems[0]) when trying to stack or find empty slot
                if (inventoryArray === beltItems && i === 0) continue;

                if (inventoryArray[i] === null) {
                    inventoryArray[i] = { ...itemToAdd }; // Add new item
                    return;
                }
            }
            console.warn("Inventory is full, could not add item:", itemToAdd.name);
        }

        // Função para atualizar a exibição do cinto de inventário
        function updateBeltDisplay() {
            inventoryBeltElement.innerHTML = ''; // Limpa os slots existentes

            // Slot esquerdo (índice 0)
            const leftSlotDiv = renderSlot(beltItems[0], 0, 'belt');
            inventoryBeltElement.appendChild(leftSlotDiv);

            // Botão da mochila
            const backpackButton = document.createElement('button');
            backpackButton.id = 'backpackButton';
            const backpackIcon = document.createElement('i');
            backpackIcon.classList.add('fas', 'fa-shopping-bag');
            backpackButton.appendChild(backpackIcon);
            backpackButton.addEventListener('click', openBackpack);
            inventoryBeltElement.appendChild(backpackButton);

            // Slot direito (índice 1)
            const rightSlotDiv = renderSlot(beltItems[1], 1, 'belt');
            inventoryBeltElement.appendChild(rightSlotDiv);

            // Atualiza a referência aos elementos dos slots para drag and drop
            slots = Array.from(inventoryBeltElement.querySelectorAll('.slot'));
        }

        // Função para atualizar a exibição da mochila
        function updateBackpackDisplay() {
            backpackSlotsContainer.innerHTML = ''; // Limpa os slots existentes
            for (let i = 0; i < numBackpackSlots; i++) {
                const item = backpackItems[i];
                const slotDiv = renderSlot(item, i, 'backpack');
                backpackSlotsContainer.appendChild(slotDiv);
            }
        }

        // Funções de drag and drop
        function startDrag(e, item, index, containerType) {
            // Se for um slot do cinto e estiver vazio (representando a mão), impede o arrasto.
            if (containerType === 'belt' && item === null) {
                return;
            }
            // Se não houver item para arrastar, impede o arrasto.
            if (e.button !== 0 || !item) return;

            isDraggingItem = true;
            draggedItem = { item: { ...item }, sourceLocation: containerType, sourceIndex: index };

            // Remove o item da origem para feedback visual.
            if (containerType === 'belt') {
                beltItems[index] = null;
            } else {
                backpackItems[index] = null;
            }
            // Atualiza a exibição para refletir a remoção do item da origem.
            updateBeltDisplay();
            updateBackpackDisplay();

            // Cria o elemento fantasma
            draggingGhostElement = document.createElement('div');
            draggingGhostElement.classList.add('dragging-ghost');
            // Renderiza o item no fantasma
            const ghostItemContent = renderSlot(item, -1, 'ghost'); // Use -1 for index and 'ghost' type
            ghostItemContent.classList.remove('slot'); // Remove slot class from ghost content
            ghostItemContent.style.cursor = 'grabbing'; // Change cursor for ghost
            draggingGhostElement.appendChild(ghostItemContent);
            document.body.appendChild(draggingGhostElement);

            // Posiciona o fantasma
            draggingGhostElement.style.left = `${e.clientX - draggingGhostElement.offsetWidth / 2}px`;
            draggingGhostElement.style.top = `${e.clientY - draggingGhostElement.offsetHeight / 2}px`;

            document.addEventListener('mousemove', onDragging);
            document.addEventListener('mouseup', onDragEnd);
        }

        function onDragging(e) {
            if (draggingGhostElement) {
                draggingGhostElement.style.left = `${e.clientX - draggingGhostElement.offsetWidth / 2}px`;
                draggingGhostElement.style.top = `${e.clientY - draggingGhostElement.offsetHeight / 2}px`;
            }
        }

        function onDragEnd(e) {
            document.removeEventListener('mousemove', onDragging);
            document.removeEventListener('mouseup', onDragEnd);

            if (!isDraggingItem) return;

            isDraggingItem = false;
            if (draggingGhostElement) {
                draggingGhostElement.remove();
                draggingGhostElement = null;
            }

            const targetElement = e.target.closest('.slot'); // Encontra o slot mais próximo

            const sourceItem = draggedItem.item;
            const sourceIndex = draggedItem.sourceIndex;
            const sourceLocation = draggedItem.sourceLocation;

            // NOVO: Adiciona um caso especial para soltar o item de volta no mesmo slot
            if (targetElement && sourceLocation === targetElement.dataset.containerType && sourceIndex == targetElement.dataset.slotIndex) {
                if (sourceLocation === 'belt') {
                    beltItems[sourceIndex] = sourceItem;
                } else {
                    backpackItems[sourceIndex] = sourceItem;
                }
            } else if (targetElement) { // Se o item foi solto em um slot válido (mas não o original)
                let targetIndex = parseInt(targetElement.dataset.slotIndex);
                let targetLocation = targetElement.dataset.containerType;
                let tempTargetInventory = targetLocation === 'belt' ? beltItems : backpackItems;
                let targetItem = tempTargetInventory[targetIndex];

                if (targetItem && targetItem.name === sourceItem.name) {
                    // Mescla pilhas se for o mesmo item
                    targetItem.quantity += sourceItem.quantity;
                } else {
                    // Troca ou move
                    let sourceInventory = sourceLocation === 'belt' ? beltItems : backpackItems;
                    let targetInventory = targetLocation === 'belt' ? beltItems : backpackItems;

                    // Coloca o item de origem no destino
                    targetInventory[targetIndex] = sourceItem;

                    // Coloca o item de destino de volta na origem (pode ser nulo)
                    if (sourceLocation === 'belt' && sourceIndex === 0) {
                        // Trata o caso especial onde a mão esquerda (slot 0) recebe o item da mochila
                        // e o item que estava na mão esquerda (se houver) vai para a mochila.
                        sourceInventory[sourceIndex] = null;
                        if (targetItem) {
                            addItemToInventory(backpackItems, targetItem);
                        }
                    } else {
                        sourceInventory[sourceIndex] = targetItem;
                    }
                }
            } else { // Solto fora de qualquer slot válido, retorna o item para o slot original
                if (sourceLocation === 'belt') {
                    beltItems[sourceIndex] = sourceItem;
                } else {
                    backpackItems[sourceIndex] = sourceItem;
                }
            }

            // Remove a classe drag-over de todos os slots
            document.querySelectorAll('.slot.drag-over').forEach(slot => {
                slot.classList.remove('drag-over');
            });

            draggedItem = null;
            updateBeltDisplay();
            updateBackpackDisplay();
        }

        function digHole() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const groundMeshes = islandMeshes.map(item => item.mesh);
            const intersects = raycaster.intersectObjects(groundMeshes);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (intersect.distance > destroyDistance) return;

                const hitPoint = intersect.point;
                if (hitPoint.y < waterLevel) return;

                // Converte a posição do mundo para as coordenadas da grade do heightfield
                const hfGridSize = 128;
                const gridX = Math.floor(((hitPoint.x + visualOffsetX + worldSize / 2) / worldSize) * (hfGridSize - 1));
                const gridZ = Math.floor(((-hitPoint.z - visualOffsetZ + worldSize / 2) / worldSize) * (hfGridSize - 1));

                // Define as dimensões do buraco e do domo
                const holeRadius = cobSize * 1.5; // Um pouco maior que uma caixa
                const holeDepth = cobSize;
                const holeGridRadius = Math.round(holeRadius / (worldSize / hfGridSize));


                // Adiciona o buraco ao array se estiver dentro dos limites
                if (gridX >= 0 && gridX < hfGridSize && gridZ >= 0 && gridZ < hfGridSize) {
                    holes.push({
                        x: gridX,
                        z: gridZ,
                        radius: holeGridRadius,
                        depth: holeDepth,
                        createdAt: world.time
                    });

                    // Cria e posiciona o domo visual
                    const domeGeometry = new THREE.SphereGeometry(holeRadius, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                    domeGeometry.scale(1, 1, -1); // Inverte a geometria para o interior ser visível
                    const domeMesh = new THREE.Mesh(domeGeometry, holeMaterial);
                    domeMesh.receiveShadow = true;

                    const domeMeshes = [];
                    for (let j = -Math.floor(numTiles / 2); j <= Math.floor(numTiles / 2); j++) {
                        for (let k = -Math.floor(numTiles / 2); k <= Math.floor(numTiles / 2); k++) {
                            const mesh = domeMesh.clone();
                            scene.add(mesh);
                            domeMeshes.push({ mesh: mesh, offsetX: j * worldSize, offsetZ: k * worldSize });
                        }
                    }

                    holeDomes.push({
                        position: hitPoint.clone().sub(new THREE.Vector3(0, 0.05, 0)), // Posição logo abaixo da superfície
                        meshes: domeMeshes,
                        createdAt: world.time
                    });


                    updateIslandGeometry(); // Atualiza a geometria do terreno

                    addItemToInventory(backpackItems, { name: dirtItemName, quantity: 1 });
                    updateBackpackDisplay();
                }
            }
        }


        // NOVO: Função para criar uma nova caixa dinâmica
        function createBox(position, quaternion) {
            const cubeSize = 1;
            const initialCubeMass = 200;
            const cubeShape = new CANNON.Box(new CANNON.Vec3(cubeSize / 2, cubeSize / 2, cubeSize / 2));
            const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

            const boxBody = new CANNON.Body({
                mass: initialCubeMass,
                shape: cubeShape,
                material: cubeMaterial,
                linearDamping: 0.3,
                angularDamping: 0.3,
                allowSleep: true,
                sleepSpeedLimit: 0.01,
                sleepTimeLimit: 1.0
            });
            boxBody.position.copy(position);
            if (quaternion) {
                boxBody.quaternion.copy(quaternion);
            }
            world.addBody(boxBody);
            boxBody.userData = {
                isCollectible: true,
                type: boxItemName,
                originalMass: initialCubeMass,
                initialPosition: new CANNON.Vec3().copy(boxBody.position)
            };

            const boxMeshes = [];
            for (let i = -Math.floor(numTiles / 2); i <= Math.floor(numTiles / 2); i++) {
                for (let j = -Math.floor(numTiles / 2); j <= Math.floor(numTiles / 2); j++) {
                    const mesh = new THREE.Mesh(cubeGeometry, cubeMaterialMesh); // Usa o material global
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData.physicsBody = boxBody;
                    scene.add(mesh);
                    boxMeshes.push({ mesh: mesh, offsetX: i * worldSize, offsetZ: j * worldSize });
                }
            }

            // Adiciona a nova caixa à lista de caixas colecionáveis
            collectibleBoxes.push({ body: boxBody, meshes: boxMeshes });
        }

        // Função para criar um novo bloco físico e visual (cob ou piso)
        function createPlaceableBlock(position, quaternion, type) {
            let blockShape, initialMass;
            let width, height, depth;
            let mesh; // This will hold either a THREE.Mesh or a THREE.Group
            let randomizedTreeDimensions = null; // To store randomized dimensions for trees
            let durability = 0;

            const blockBody = new CANNON.Body({
                mass: 0, // Blocos colocados são estáticos (massa 0)
                type: CANNON.Body.STATIC, // Blocos colocados são estáticos
                material: constructionMaterial, // Usar o novo material de construção
                linearDamping: 0.99,
                angularDamping: 0.99,
                allowSleep: true,
                sleepSpeedLimit: 0.01,
                sleepTimeLimit: 1.0
            });
            blockBody.position.copy(position);
            if (quaternion) {
                blockBody.quaternion.copy(quaternion);
            }

            if (type === 'cob') {
                width = cobWidth;
                height = cobHeight;
                depth = cobDepth;
                blockShape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
                blockBody.addShape(blockShape); // Add the single shape
                mesh = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), cobMaterialMesh);
                initialMass = initialCobMass;
                durability = cobDurability;
            } else if (type === 'piso') {
                width = floorWidth;
                height = floorHeight;
                depth = floorDepth;
                blockShape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
                blockBody.addShape(blockShape); // Add the single shape
                mesh = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), floorMaterialMesh);
                initialMass = initialFloorMass;
                durability = floorDurability;
            } else if (type === 'muda_arvore') {
                // Ao colocar uma 'muda', na verdade começamos com o estágio 'semente'
                randomizedTreeDimensions = randomizeTreeDimensions(treeStages['semente']);
                const stageData = randomizedTreeDimensions; // Usa dados randomizados

                // Ajusta a posição Y do corpo para alinhar o modelo visual com o chão
                const groupHeightVisual = stageData.visual.sphere.radius * 2;
                const overallPhysicsHeight = stageData.overallPhysicsHeight;
                position.y += (groupHeightVisual / 2) - (overallPhysicsHeight / 2);

                initialMass = initialTreeSaplingMass;
                durability = treeSaplingDurability;

                // Adiciona a forma de física (caixa minúscula para a semente)
                const trunkPhysics = stageData.physics.trunk;
                const trunkShape = new CANNON.Box(new CANNON.Vec3(trunkPhysics.width / 2, trunkPhysics.height / 2, trunkPhysics.depth / 2));
                blockBody.addShape(trunkShape, new CANNON.Vec3(0, trunkPhysics.yOffset, 0));

                // O visual da semente é agora uma única esfera
                const seedMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Cor de terra/marrom
                const seedGeometry = new THREE.SphereGeometry(stageData.visual.sphere.radius, 8, 8);
                const seedMesh = new THREE.Mesh(seedGeometry, seedMaterial);
                seedMesh.castShadow = true;

                mesh = seedMesh; // A malha é a esfera, não um grupo
                width = stageData.overallPhysicsHeight;
                height = stageData.overallPhysicsHeight;
                depth = stageData.overallPhysicsHeight;
            } else if (type === 'tronco_arvore') { // NOVO: Bloco de tronco de árvore
                width = trunkRadius * 2; // Diâmetro para largura
                height = trunkHeight;
                depth = trunkRadius * 2; // Diâmetro para profundidade
                blockShape = new CANNON.Cylinder(trunkRadius, trunkRadius, trunkHeight, trunkSegments);
                blockBody.addShape(blockShape);
                mesh = new THREE.Mesh(new THREE.CylinderGeometry(trunkRadius, trunkRadius, trunkHeight, trunkSegments), treeTrunkMaterialMesh);
                initialMass = initialTrunkMass;
                durability = treeTrunkDurability;
            } else if (type === 'tábuas') { // NOVO: Bloco de tábuas de madeira
                width = woodenPlankWidth;
                height = woodenPlankHeight;
                depth = woodenPlankDepth;
                blockShape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
                blockBody.addShape(blockShape);
                mesh = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), woodenPlankMaterialMesh);
                initialMass = initialWoodenPlankMass;
                durability = woodenPlankDurability;
            }
            else {
                console.error('Tipo de bloco desconhecido:', type);
                return;
            }

            world.addBody(blockBody);
            blockBody.userData = {
                isDestructible: true,
                durability: durability,
                originalMass: initialMass, // Mantém a massa original para referência, mas o corpo é estático
                initialPosition: new CANNON.Vec3().copy(blockBody.position),
                type: type, // Armazena o tipo de bloco
                dimensions: { width, height, depth }, // Armazena as dimensões para referência (overall for trees)
                initialDimensions: { width, height, depth }, // Store initial dimensions for growth
                growthStage: (type === 'muda_arvore') ? 'semente' : null, // O estágio de crescimento inicial para árvores é 'semente'
                growthStartTime: (type === 'muda_arvore') ? world.time : null, // Time when placed for trees
                randomizedDimensions: randomizedTreeDimensions // Store randomized dimensions for trees
            };
            placedConstructionBodies.push(blockBody);
            console.log("Bloco colocado. Corpos de construção colocados:", placedConstructionBodies); // Log para depuração

            const blockMeshes = [];
            for (let i = -Math.floor(numTiles / 2); i <= Math.floor(numTiles / 2); i++) {
                for (let j = -Math.floor(numTiles / 2); j <= Math.floor(numTiles / 2); j++) {
                    // We clone the visual object (whether it's a mesh or a group) for each tile.
                    const visualObject = mesh.clone();
                    visualObject.userData.physicsBody = blockBody; // Link the clone back to the single physics body
                    scene.add(visualObject);
                    blockMeshes.push({ mesh: visualObject, offsetX: i * worldSize, offsetZ: j * worldSize });
                }
            }
            placedConstructionMeshesArrays.push(blockMeshes);
        }

        // Function to create a smoke effect at a given position
        function createSmokeEffect(position) {
            const smokeCount = 10; // Number of smoke particles
            const smokeGeometry = new THREE.SphereGeometry(0.05, 8, 8); // Small spheres
            const smokeMaterial = new THREE.MeshBasicMaterial({
                color: 0x888888, // Grey color
                transparent: true,
                opacity: 0.5,
                depthWrite: false // Important for transparent objects
            });

            for (let i = 0; i < smokeCount; i++) {
                const particle = new THREE.Mesh(smokeGeometry, smokeMaterial.clone()); // Clone material for individual opacity
                particle.position.copy(position);
                // Give particles a slight random initial velocity
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5, // X velocity
                    Math.random() * 0.5 + 0.1,   // Y velocity (mostly upwards)
                    (Math.random() - 0.5) * 0.5  // Z velocity
                );
                particle.userData.lifetime = 1.0; // Lifetime in seconds
                scene.add(particle);
                smokeParticles.push(particle);
            }
        }


        // NOVO: Função para atualizar a geometria e física da ilha (movida para o escopo global)
        function updateIslandGeometry() {
            const hfGridSize = 128;
            const hfMatrix = JSON.parse(JSON.stringify(baseMatrix)); // Começa com a geometria base

            // Zera o splatMap
            for (let i = 0; i < splatMapData.length; i++) {
                splatMapData[i] = 0;
            }

            // Itera sobre cada buraco para aplicar a deformação e pintar a máscara de textura
            for (const hole of holes) {
                for (let i = 0; i < hfGridSize; i++) {
                    for (let j = 0; j < hfGridSize; j++) {
                        const dx = j - hole.x;
                        const dz = i - hole.z;
                        const distSq = dx * dx + dz * dz;
                        const radiusSq = hole.radius * hole.radius;

                        if (distSq < radiusSq) {
                            // Deformação da geometria (domo invertido)
                            const heightOffset = Math.sqrt(radiusSq - distSq) * (hole.depth / hole.radius);
                            hfMatrix[i][j] = baseMatrix[i][j] - heightOffset;

                            // "Pinta" a área do buraco no splatMap (branco)
                            const splatIndex = (i * hfGridSize + j);
                            splatMapData[splatIndex] = 255;
                        }
                    }
                }
            }

            // Atualiza o splatMap
            splatMap.needsUpdate = true;

            // Atualiza a forma de física
            if (islandBody && islandBody.shapes.length > 0) {
                const newHfShape = new CANNON.Heightfield(hfMatrix, { elementSize: worldSize / (hfGridSize - 1) });
                islandBody.removeShape(islandBody.shapes[0]);
                islandBody.addShape(newHfShape);
                islandBody.wakeUp();
            }

            // Atualiza a geometria visual
            if (islandMeshes.length > 0) {
                const mainIslandMesh = islandMeshes[0].mesh;
                const vertices = mainIslandMesh.geometry.attributes.position.array;
                for (let i = 0; i < hfGridSize; i++) {
                    for (let j = 0; j < hfGridSize; j++) {
                        const height = hfMatrix[i][j];
                        const index = (i * hfGridSize + j) * 3;
                        vertices[index + 1] = height;
                    }
                }
                mainIslandMesh.geometry.attributes.position.needsUpdate = true;
                mainIslandMesh.geometry.computeVertexNormals();
            }
        }

        // Função de inicialização para cena, câmera, renderizador e mundo da física
        function init() {
            window.THREE = THREE;
            window.CANNON = CANNON;
            // Define o offset inicial do nível dos olhos da câmera como o raio da esfera
            cameraEyeLevelOffset = playerRadius;
            originalCameraEyeLevelOffset = cameraEyeLevelOffset; // Para armazenar o valor inicial

            // Configuração da Cena Three.js
            scene = new THREE.Scene();
            window.scene = scene;
            skyColor = new THREE.Color(0x87CEEB);
            underwaterColor = new THREE.Color(0x001e3d);
            scene.background = skyColor; // Começa com a cor do céu

            // Inicializa ambos os nevoeiros
            skyFog = new THREE.Fog(skyColor, 100, 200);
            underwaterFog = new THREE.Fog(underwaterColor, 1, 30); // Nevoeiro denso para debaixo d'água

            scene.fog = skyFog; // Começa com o nevoeiro do céu

            // Configuração da Câmera Three.js
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
            window.camera = camera; // Expose for debug
            camera.rotation.order = 'YXZ'; // Define a ordem de rotação para guinada (Y), inclinação (X), rolagem (Z)

            // Configuração do Renderizador Three.js
            renderer = new THREE.WebGLRenderer({ antialiased: true }); // Habilita antialiasing para gráficos mais suaves
            renderer.setSize(window.innerWidth, window.innerHeight); // Define o tamanho do renderizador para o tamanho da janela
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement); // Adiciona o canvas ao corpo do documento

            // Configuração do Mundo Cannon-es (física)
            world = new CANNON.World();
            world.gravity.set(0, -30, 0); // Define a gravidade (para baixo), aumentada para -30
            world.solver.iterations = 40; // Aumenta as iterações do solver para melhor estabilidade (de 20 para 40)

            // Inicializa os materiais de física
            playerMaterial = new CANNON.Material('playerMaterial');
            islandMaterial = new CANNON.Material('islandMaterial'); // Material para terreno e estrada
            cubeMaterial = new CANNON.Material('cubeMaterial');
            constructionMaterial = new CANNON.Material('constructionMaterial'); // Novo material para cobs e pisos

            // Define material de contato entre jogador e terreno/estrada
            const playerGroundContactMaterial = new CANNON.ContactMaterial(
                playerMaterial,
                islandMaterial,
                {
                    friction: 0, // Attrition set to 0
                    restitution: 0,
                    contactEquationStiffness: 1e9, // Increased for higher rigidity
                    contactEquationRelaxation: 3
                }
            );
            world.addContactMaterial(playerGroundContactMaterial);

            // Material de contato entre jogador e blocos de construção (cobs/pisos)
            const playerConstructionContactMaterial = new CANNON.ContactMaterial(
                playerMaterial,
                constructionMaterial,
                {
                    friction: 0, // CRUCIAL: Atrito zero para evitar que o jogador "cole"
                    restitution: 0,
                    contactEquationStiffness: 1e9, // Alta rigidez
                    contactEquationRelaxation: 3
                }
            );
            world.addContactMaterial(playerConstructionContactMaterial);

            // Material de contato entre cubo e terreno/estrada
            const cubeGroundContactMaterial = new CANNON.ContactMaterial(
                cubeMaterial,
                islandMaterial,
                {
                    friction: 0.7,
                    restitution: 0,
                    contactEquationStiffness: 1e8, // Aumenta a rigidez para evitar que os objectos se "afundem"
                    contactEquationRelaxation: 4    // Proporciona um ligeiro "amortecimento" para evitar o ressalto
                }
            );
            world.addContactMaterial(cubeGroundContactMaterial);

            // Material de contato entre cubo e jogador
            const cubePlayerContactMaterial = new CANNON.ContactMaterial(
                cubeMaterial,
                playerMaterial,
                {
                    friction: 0, // Attrition set to 0
                    restitution: 0,
                    contactEquationStiffness: 1e9, // Increased for higher rigidity
                    contactEquationRelaxation: 20
                }
            );
            world.addContactMaterial(cubePlayerContactMaterial);

            // Material de contato entre cubo e cubo
            const cubeCubeContactMaterial = new CANNON.ContactMaterial(
                cubeMaterial,
                cubeMaterial,
                {
                    friction: 0,
                    restitution: 0,
                    contactEquationStiffness: 1e8,
                    contactEquationRelaxation: 3
                }
            );
            world.addContactMaterial(cubeCubeContactMaterial);

            // Material de contato entre blocos de construção e terreno/estrada (podem ter atrito)
            const constructionGroundContactMaterial = new CANNON.ContactMaterial(
                constructionMaterial,
                islandMaterial,
                {
                    friction: 0.7, // Blocos podem ter atrito com o chão
                    restitution: 0
                }
            );
            world.addContactMaterial(constructionGroundContactMaterial);

            // Material de contato entre blocos de construção e cubos (podem ter atrito)
            const constructionCubeContactMaterial = new CANNON.ContactMaterial(
                constructionMaterial,
                cubeMaterial,
                {
                    friction: 0.7, // Blocos podem ter atrito com cubos
                    restitution: 0
                }
            );
            world.addContactMaterial(constructionCubeContactMaterial);

            // Material de contato entre blocos de construção (cob com cob, piso com piso, etc.)
            const constructionConstructionContactMaterial = new CANNON.ContactMaterial(
                constructionMaterial,
                constructionMaterial,
                {
                    friction: 0.7, // Attrito entre blocos de construção
                    restitution: 0
                }
            );
            world.addContactMaterial(constructionConstructionContactMaterial);


            // Configuração das Luzes
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Luz ambiente suave
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Luz direcional (simula o sol)
            directionalLight.position.set(10, 15, 10); // Posição inicial
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            scene.add(directionalLight.target); // Adiciona o alvo à cena para atualizações de posição

            // Cria o Terreno (Ilha Redonda)
            // A geometria visual é agora um plano segmentado cujos vértices correspondem ao Heightfield.
            const hfGridSize = 128; // A resolução DEVE corresponder à do Heightfield
            const islandGeometry = new THREE.PlaneGeometry(worldSize, worldSize, hfGridSize - 1, hfGridSize - 1);

            // --- Criação do Corpo de Física da Ilha com Heightfield ---
            const hfMatrix = [];
            for (let i = 0; i < hfGridSize; i++) {
                hfMatrix.push([]);
                for (let j = 0; j < hfGridSize; j++) {
                    // Mapeia os índices da grelha para coordenadas do mundo
                    const x = (j / (hfGridSize - 1) - 0.5) * worldSize;
                    const z = (i / (hfGridSize - 1) - 0.5) * worldSize;
                    const distance = Math.sqrt(x * x + z * z);
                    let height;

                    if (distance <= islandRadiusTop) {
                        height = islandSurfaceHeight;
                    } else if (distance <= islandRadiusBottom) {
                        // Interpola linearmente da superfície da ilha para o fundo do mar
                        const t = (distance - islandRadiusTop) / (islandRadiusBottom - islandRadiusTop);
                        height = islandSurfaceHeight * (1 - t) + seabedLevel * t;
                    } else {
                        height = seabedLevel;
                    }
                    hfMatrix[i][j] = height;
                }
            }
            baseMatrix = JSON.parse(JSON.stringify(hfMatrix)); // Armazena a geometria inicial

            // Inicializa o splatMap para os buracos
            splatMapData = new Uint8Array(hfGridSize * hfGridSize).fill(0);
            splatMap = new THREE.DataTexture(splatMapData, hfGridSize, hfGridSize, THREE.LuminanceFormat);
            splatMap.needsUpdate = true;


            // Gira a geometria para ficar no plano XZ.
            islandGeometry.rotateX(-Math.PI / 2);

            // Define a altura de cada vértice na geometria para corresponder à matriz do Heightfield.
            const vertices = islandGeometry.attributes.position.array;
            for (let i = 0; i < hfGridSize; i++) {
                for (let j = 0; j < hfGridSize; j++) {
                    const height = hfMatrix[i][j];
                    const index = (i * hfGridSize + j) * 3;
                    vertices[index + 1] = height; // Atualiza a coordenada Y
                }
            }
            islandGeometry.attributes.position.needsUpdate = true;
            islandGeometry.computeVertexNormals(); // Recalcula as normais para uma iluminação correta

            const hfShape = new CANNON.Heightfield(hfMatrix, {
                elementSize: worldSize / (hfGridSize - 1)
            });

            islandBody = new CANNON.Body({ mass: 0, material: islandMaterial });
            islandBody.addShape(hfShape);
            // Os Heightfields são criados no plano XY, por isso rodamos para o plano XZ.
            islandBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            // Posiciona o corpo no canto do mundo para alinhar a grelha.
            islandBody.position.set(-worldSize / 2, 0, worldSize / 2);
            world.addBody(islandBody);
            const groundTextureURL = "https://dl.dropbox.com/scl/fi/gdiu7zb9234a8jm68z7f3/textura-de-terra.png?rlkey=li8ncb3e8px530q9kjuu6t7e2&st=31pn526c&dl=0";
            const sandTextureURL = "https://dl.dropbox.com/scl/fi/2ediqx91o54kqrua9l4jk/Textura-de-areia.png?rlkey=pale1g1zkjqlrkjhpz4kr3ypw&st=fbuzn6iu&dl=0";
            const seabedTextureURL = sandTextureURL;

            textureLoader.load(groundTextureURL, (groundTexture) => {
                textureLoader.load(seabedTextureURL, (seabedTexture) => {
                    textureLoader.load(sandTextureURL, (sandTexture) => {
                        textureLoader.load(holeTextureURL, (holeTexture) => { // NOVO: Carrega a textura do buraco
                            // Todas as quatro texturas estão carregadas
                            [groundTexture, seabedTexture, sandTexture, holeTexture].forEach(texture => {
                                texture.wrapS = THREE.RepeatWrapping;
                                texture.wrapT = THREE.RepeatWrapping;
                            });
                            groundTexture.repeat.set(islandRadiusTop / 4, islandRadiusTop / 4);
                            seabedTexture.repeat.set(islandRadiusTop / 4, islandRadiusTop / 4);
                            sandTexture.repeat.set(islandRadiusTop / 4, islandRadiusTop / 4);
                            holeTexture.repeat.set(islandRadiusTop / 16, islandRadiusTop / 16); // Repetição diferente para a textura do buraco

                            const islandMeshMaterial = new THREE.MeshStandardMaterial({
                                map: groundTexture,
                            });

                            islandMeshMaterial.onBeforeCompile = (shader) => {
                                shader.uniforms.uSeabedTexture = { value: seabedTexture };
                                shader.uniforms.uSandTexture = { value: sandTexture };
                                shader.uniforms.uWaterLevel = { value: waterLevel };
                                shader.uniforms.uSplatMap = { value: splatMap }; // NOVO: Uniform para o splat map
                                shader.uniforms.uHoleTexture = { value: holeTexture }; // NOVO: Uniform para a textura do buraco

                                shader.vertexShader = `
                                    varying vec3 vWorldPosition;
                                    ${shader.vertexShader}
                                `.replace(
                                    `#include <worldpos_vertex>`,
                                    `
                                    #include <worldpos_vertex>
                                    vWorldPosition = worldPosition.xyz;
                                    `
                                );

                                shader.fragmentShader = `
                                    uniform sampler2D uSeabedTexture;
                                    uniform sampler2D uSandTexture;
                                    uniform float uWaterLevel;
                                    uniform sampler2D uSplatMap;
                                    uniform sampler2D uHoleTexture;
                                    varying vec3 vWorldPosition;
                                    ${shader.fragmentShader}
                                `.replace(
                                    `#include <map_fragment>`,
                                    `
                                    #ifdef USE_MAP
                                        vec4 groundColor = texture2D(map, vUv);
                                        vec4 seabedColor = texture2D(uSeabedTexture, vUv);
                                        vec4 sandColor = texture2D(uSandTexture, vUv);
                                        vec4 holeColor = texture2D(uHoleTexture, vUv);

                                        // Mistura de texturas do terreno (areia, fundo do mar, grama)
                                        float seabedToSandBlend = smoothstep(uWaterLevel - 2.0, uWaterLevel - 0.5, vWorldPosition.y);
                                        vec3 seabedSandMix = mix(seabedColor.rgb, sandColor.rgb, seabedToSandBlend);
                                        float sandToGrassBlend = smoothstep(uWaterLevel, 0.4, vWorldPosition.y);
                                        vec3 terrainMix = mix(seabedSandMix, groundColor.rgb, sandToGrassBlend);

                                        // Aplica o "splatting" para criar buracos transparentes
                                        float splatValue = texture2D(uSplatMap, vUv).r;
                                        if (splatValue > 0.5) {
                                            discard; // Descarta o fragmento, criando um buraco transparente
                                        }

                                        // A cor final é apenas a mistura do terreno, já que os buracos são descartados
                                        diffuseColor *= vec4(terrainMix, 1.0);
                                    #endif
                                    `
                                );
                            };

                            for (let i = -Math.floor(numTiles / 2); i <= Math.floor(numTiles / 2); i++) {
                                for (let j = -Math.floor(numTiles / 2); j <= Math.floor(numTiles / 2); j++) {
                                    const islandMesh = new THREE.Mesh(islandGeometry, islandMeshMaterial);
                                    islandMesh.receiveShadow = true;
                                    islandMesh.userData.physicsBody = islandBody;
                                    scene.add(islandMesh);
                                    islandMeshes.push({ mesh: islandMesh, offsetX: i * worldSize, offsetZ: j * worldSize });
                                }
                            }
                            islandMeshMaterial.needsUpdate = true;
                        }, undefined, (error) => console.error('Falha ao carregar a textura do buraco:', error));
                    }, undefined, (error) => console.error('Falha ao carregar a textura de areia:', error));
                }, undefined, (error) => console.error('Falha ao carregar a textura do fundo do mar:', error));
            }, undefined, (error) => console.error('Falha ao carregar a textura do solo:', error));

            // Cria a Água (agora como uma grelha)
            const waterGeometry = new THREE.BoxGeometry(worldSize, 0.1, worldSize);
            const waterMaterial = new THREE.MeshBasicMaterial({ color: 0x006994, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
            for (let i = -Math.floor(numTiles / 2); i <= Math.floor(numTiles / 2); i++) {
                for (let j = -Math.floor(numTiles / 2); j <= Math.floor(numTiles / 2); j++) {
                    const mesh = new THREE.Mesh(waterGeometry, waterMaterial);
                    mesh.position.y = waterLevel - 0.05; // Posição visual da água
                    mesh.userData.isWater = true; // Identificador para o raycaster
                    scene.add(mesh);
                    waterMeshes.push({ mesh: mesh, offsetX: i * worldSize, offsetZ: j * worldSize });
                }
            }

            // O fundo do mar é agora renderizado pela própria ilha, pelo que esta secção foi removida.

            // A rua foi removida, então o código relacionado a ela foi excluído.

            // Cria o Corpo de Física do Jogador (esfera)
            originalPlayerShape = new CANNON.Sphere(playerRadius); // Esfera com raio baseado na altura
            crouchPlayerShape = new CANNON.Sphere(crouchRadius);   // Esfera agachada

            playerBody = new CANNON.Body({
                mass: 80,
                shape: originalPlayerShape, // Começa com a forma original
                material: playerMaterial,
                linearDamping: 0.9, // Reverted to a higher damping for better stop-on-a-dime feel
                angularDamping: 0.9,
                fixedRotation: true, // Mantém rotação fixa para a câmera
                allowSleep: true, // Permite que o jogador entre em modo de "sono"
                sleepSpeedLimit: 0.01, // Velocidade linear mínima para "acordar"
                sleepTimeLimit: 1.0 // Tempo mínimo em repouso para "adormecer"
            });
            // Posição inicial: centro da esfera em playerRadius + islandSurfaceHeight
            playerBody.position.set(0, playerRadius + islandSurfaceHeight, 0); // Posição inicial ajustada do jogador
            world.addBody(playerBody);

            // Reintroduz o listener de colisão para canJump, mas com uma verificação adicional
            playerBody.addEventListener('collide', (event) => {
                // canJump é verdadeiro APENAS se o corpo colidido NÃO for o objeto que está sendo segurado
                // A lista de corpos "chão" agora inclui apenas superfícies que podem ser pisadas
                const allGroundBodies = [islandBody, ...collectibleBoxes.map(b => b.body), ...placedConstructionBodies];
                if (event.body !== pickedObjectBody && allGroundBodies.includes(event.body)) {
                    canJump = true;
                }
            });

            // --- Configuração dos Cubos Interativos ---
            const cubeSize = 1;
            // Carrega a textura para os cubos e cria o material global
            const cubeTexture = textureLoader.load(cubeTextureURL);
            cubeTexture.wrapS = THREE.RepeatWrapping;
            cubeTexture.wrapT = THREE.RepeatWrapping;
            cubeTexture.repeat.set(1, 1);
            cubeMaterialMesh = new THREE.MeshStandardMaterial({ map: cubeTexture });

            // Cria as caixas iniciais usando a função createBox
            createBox(new THREE.Vector3(0, cubeSize / 2 + islandSurfaceHeight, -10));
            createBox(new THREE.Vector3(5, cubeSize / 2 + islandSurfaceHeight, -10));
            createBox(new THREE.Vector3(-5, cubeSize / 2 + islandSurfaceHeight, -10));

            // Cria o ghost block (transparente)
            const ghostBlockMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00, // Verde para indicar que pode ser colocado
                transparent: true,
                opacity: 0.5,
                depthWrite: false // Importante para renderizar corretamente sobre outros objetos
            });
            // Inicializa com a geometria do cob, será atualizada em updateSelectedSlot
            ghostBlockMesh = new THREE.Mesh(new THREE.BoxGeometry(cobWidth, cobHeight, cobDepth), ghostBlockMaterial);
            ghostBlockMesh.visible = false; // Inicialmente invisível
            scene.add(ghostBlockMesh);

            // NOVO: Carrega a textura de pedra para a ferramenta aplicadora
            textureLoader.load(stoneTextureURL, (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1); // A textura cobre um patch
                stoneMaterial = new THREE.MeshStandardMaterial({ map: texture });
            }, undefined, (error) => {
                console.error('Erro ao carregar a textura de pedra:', error);
                stoneMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 }); // Fallback cinza
            });

            // NOVO: Carrega a textura do buraco para a ferramenta pá
            textureLoader.load(holeTextureURL, (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
                holeMaterial = new THREE.MeshStandardMaterial({ map: texture, transparent: true }); // Transparente para misturar com o terreno
            }, undefined, (error) => {
                console.error('Erro ao carregar a textura do buraco:', error);
                holeMaterial = new THREE.MeshStandardMaterial({ color: 0x3b2712 }); // Fallback marrom escuro
            });

            // Load the cob texture and create the material once
            textureLoader.load(cobTextureURL, (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
                cobMaterialMesh = new THREE.MeshStandardMaterial({ map: texture }); // Create the material here
            }, undefined, (error) => {
                console.error('Erro ao carregar a textura do cob:', error);
                // Fallback to a plain color if texture fails to load
                cobMaterialMesh = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown color
            });

            // Load the floor texture and create the material once
            textureLoader.load(floorTextureURL, (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
                floorMaterialMesh = new THREE.MeshStandardMaterial({ map: texture }); // Create the material here
            }, undefined, (error) => {
                console.error('Erro ao carregar a textura do piso:', error);
                // Fallback to a plain color if texture fails to load
                floorMaterialMesh = new THREE.MeshStandardMaterial({ color: 0xAAAAAA }); // Grey color for floor
            });

            // Load the wooden plank texture and create the material once
            textureLoader.load(woodenPlankTextureURL, (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
                woodenPlankMaterialMesh = new THREE.MeshStandardMaterial({ map: texture });
            }, undefined, (error) => {
                console.error('Erro ao carregar a textura da tábua de madeira:', error);
                woodenPlankMaterialMesh = new THREE.MeshStandardMaterial({ color: 0xdeb887 }); // Fallback brown
            });

            // Load the tree sapling texture (for icon) and create the material once
            textureLoader.load(treeSaplingTextureURL, (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
                treeSaplingMaterialMesh = new THREE.MeshStandardMaterial({ map: texture });
            }, undefined, (error) => {
                console.error('Erro ao carregar a textura da muda de árvore:', error);
                treeSaplingMaterialMesh = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Dark green color
            });

            // Load tree bark texture and create material
            textureLoader.load(treeBarkTextureURL, (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1); // Adjust as needed for bark
                treeTrunkMaterialMesh = new THREE.MeshStandardMaterial({ map: texture });
            }, undefined, (error) => {
                console.error('Erro ao carregar a textura do tronco da árvore:', error);
                treeTrunkMaterialMesh = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Fallback brown
            });

            // Load tree leaves texture and create material
            textureLoader.load(treeLeavesTextureURL, (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1); // Adjust as needed for leaves
                treeLeavesMaterialMesh = new THREE.MeshStandardMaterial({ map: texture, transparent: true, alphaTest: 0.5 }); // alphaTest for transparency
            }, undefined, (error) => {
                console.error('Erro ao carregar a textura das folhas da árvore:', error);
                treeLeavesMaterialMesh = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Fallback dark green
            });

            // Cria um corpo "grabber" invisível para segurar objetos
            grabberBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
            world.addBody(grabberBody);

            // Inicializa o Raycaster
            raycaster = new THREE.Raycaster();

            // Pega o elemento da mira
            crosshairElement = document.getElementById('crosshair');

            // Pega elementos da barra de progresso
            progressContainer = document.getElementById('progressContainer');
            progressBar = document.getElementById('progressBar');

            // Pega o elemento do botão de ícone do menu
            menuIconButton = document.getElementById('menuIconButton');

            // Pega elementos da mochila
            backpackModal = document.getElementById('backpackModal');
            backpackSlotsContainer = document.getElementById('backpackSlotsContainer');

            // Inicializa o inventário
            beltItems = new Array(numBeltSlots).fill(null); // Garante que esteja vazio primeiro
            backpackItems = new Array(numBackpackSlots).fill(null);

            // Itens padrão para os dois slots do cinto
            // beltItems[0] agora começa como null para representar a mão quando vazio
            beltItems[1] = { name: axeItemName, quantity: 1 }; // Machado no slot direito (secundário)

            // Adiciona outros itens diretamente na mochila
            addItemToInventory(backpackItems, { name: hammerItemName, quantity: 1 });
            addItemToInventory(backpackItems, { name: stoneItemName, quantity: 1 }); // NOVO
            addItemToInventory(backpackItems, { name: dirtItemName, quantity: 1 }); // NOVO
            addItemToInventory(backpackItems, { name: shovelItemName, quantity: 1 }); // NOVO
            addItemToInventory(backpackItems, { name: textureApplicatorItemName, quantity: 1 });
            addItemToInventory(backpackItems, { name: cobItemName, quantity: 100 });
            addItemToInventory(backpackItems, { name: floorItemName, quantity: 50 });
            addItemToInventory(backpackItems, { name: treeSaplingItemName, quantity: 10 });
            addItemToInventory(backpackItems, { name: treeTrunkItemName, quantity: 20 }); // NOVO: Adiciona troncos de árvore à mochila
            addItemToInventory(backpackItems, { name: woodenPlankItemName, quantity: 10 }); // NOVO: Adiciona tábuas de madeira à mochila
            addItemToInventory(backpackItems, { name: boxItemName, quantity: 20 }); // Adiciona 20 caixas ao inventário inicial

            // Pega o elemento do cinto de inventário e seus slots
            inventoryBeltElement = document.getElementById('inventoryBelt');
            updateBeltDisplay(); // Preenche os slots inicialmente

            // Configura os Listeners de Eventos para teclado e mouse
            window.addEventListener('keydown', (event) => {
                // A lógica de Escape/Menu deve funcionar mesmo que o mundo não esteja pronto
                if (event.key === 'Escape') {
                    event.preventDefault(); // IMPEDE O COMPORTAMENTO PADRÃO DO NAVEGADOR (sair do pointer lock)

                    if (gamePaused) {
                        hideOptionsScreen(); // Se o menu estiver aberto, fecha-o
                    } else if (document.pointerLockElement === renderer.domElement) {
                        // Se o jogo estiver a correr e o ponteiro estiver bloqueado,
                        // libertamos o bloqueio do ponteiro. O evento 'pointerlockchange'
                        // irá então tratar de mostrar o menu.
                        document.exitPointerLock();
                    } else {
                        // Se o jogo não estiver pausado e o ponteiro não estiver bloqueado
                        // (ex: logo após iniciar o jogo e não clicou no canvas),
                        // podemos mostrar o menu diretamente.
                        showOptionsScreen();
                    }
                }

                // Toggle backpack with 'B' key
                if (event.key.toLowerCase() === 'b') {
                    if (backpackModal.classList.contains('active')) {
                        closeBackpack();
                    } else {
                        openBackpack();
                    }
                }

                // NOVO: Seleção de slots com Q e E
                if (!gamePaused && !backpackModal.classList.contains('active')) {
                    if (event.key.toLowerCase() === 'q') {
                        selectedSlotIndex = 0;
                        updateBeltDisplay();
                    } else if (event.key.toLowerCase() === 'e') {
                        selectedSlotIndex = 1;
                        updateBeltDisplay();
                    }

                    keysPressed[event.key.toLowerCase()] = true;
                    if (event.key.toLowerCase() === ' ') { // Pular
                        const playerBottomY = playerBody.position.y - (isCrouching ? crouchRadius : playerRadius);
                        const isInWater = playerBottomY < waterLevel;
                        if (canJump || isInWater) {
                            // Impulso de salto mais forte necessário para sair da água
                            const jumpImpulse = isInWater ? 600 * 3 : 400 * 3;
                            playerBody.applyImpulse(new CANNON.Vec3(0, jumpImpulse, 0), playerBody.position);
                            canJump = false; // Impede pulos múltiplos
                            if (isInWater) {
                                isWaterJumping = true;
                                // Desativa temporariamente as forças de flutuação para permitir que o salto tenha efeito
                                setTimeout(() => { isWaterJumping = false; }, 500); // Reativa após meio segundo
                            }
                        }
                    }
                }
            });
            window.addEventListener('keyup', (event) => {
                // Sempre permite que os eventos de soltar tecla desregistrem as teclas, mesmo se pausado
                keysPressed[event.key.toLowerCase()] = false;
            });

            // Adiciona um listener para bloquear o ponteiro do mouse no clique do canvas
            renderer.domElement.addEventListener('click', () => {
                // Solicita o bloqueio do ponteiro apenas se o jogo não estiver pausado e a mochila não estiver aberta
                if (isWorldReady && !gamePaused && !backpackModal.classList.contains('active') && document.pointerLockElement !== renderer.domElement) { // Verifica se o ponteiro já está bloqueado
                    if (renderer && renderer.domElement) { // Adicionado verificação para renderer.domElement
                        renderer.domElement.requestPointerLock().catch(error => { // Adicionado .catch()
                            if (error.name === 'SecurityError' && error.message.includes('exited the lock')) {
                                console.warn('Solicitação de bloqueio do ponteiro falhou porque o utilizador saiu do bloqueio prematuramente.');
                            } else {
                                console.error('Erro ao solicitar bloqueio do ponteiro:', error);
                            }
                        });
                    }
                }
            });

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === renderer.domElement) {
                    // Ponteiro bloqueado (jogo a correr)
                    isDragging = true;
                    document.body.style.cursor = 'none'; // Esconde o cursor
                    if (renderer && renderer.domElement) {
                        renderer.domElement.style.cursor = 'none'; // Garante que o cursor do canvas também esteja oculto
                    }
                    // Garante que o menu esteja escondido e o jogo não esteja pausado
                    document.getElementById('optionsScreen').classList.remove('active');
                    document.getElementById('crosshair').style.display = 'flex'; // Mostra a mira
                    if (menuIconButton) {
                        menuIconButton.style.display = 'flex'; // Mostra o botão do menu
                    }
                    if (inventoryBeltElement) {
                        inventoryBeltElement.style.visibility = 'visible'; // Mostra o cinto de inventário
                        inventoryBeltElement.style.opacity = '1';
                    }
                    backpackModal.classList.remove('active'); // Garante que a mochila esteja fechada
                    gamePaused = false;
                } else {
                    // Ponteiro desbloqueado (saiu do bloqueio)
                    isDragging = false;
                    // Lida com a libertação de objetos, se houver
                    if (pickedObjectBody) {
                        if (grabberConstraint) {
                            world.removeConstraint(grabberConstraint);
                            grabberConstraint = null; // Limpa a referência da restrição
                        }
                        // O objeto já é dinâmico, então não precisamos restaurar massa/tipo
                        pickedObjectBody.wakeUp();
                        pickedObjectBody.allowSleep = true;

                        pickedObjectBody = null;
                        pickedObjectMesh = null;

                        // Ao soltar o objeto, zera a velocidade do jogador para evitar arrasto residual
                        playerBody.velocity.set(0,0,0);
                        playerBody.angularVelocity.set(0,0,0);
                        playerBody.allowSleep = true; // Permite que o jogador volte a dormir se estiver parado
                        return; // Sai da função para evitar pegar outro objeto imediatamente
                    }

                    // Reinicia a destruição se o pointer lock for perdido
                    isDestroying = false;
                    destroyProgress = 0;
                    progressContainer.style.display = 'none';

                    document.body.style.cursor = 'default'; // Mostra o cursor
                    if (renderer && renderer.domElement) {
                        renderer.domElement.style.cursor = 'default'; // Mostra o cursor do canvas
                    }
                    crosshairElement.style.setProperty('--crosshair-color', 'white');
                    if (ghostBlockMesh) {
                        ghostBlockMesh.visible = false; // Oculta o ghost block
                    }

                    // Se o bloqueio do ponteiro foi perdido e NÃO foi por causa da mochila
                    if (!pointerLockExitForBackpack) {
                        showOptionsScreen(); // Isso irá definir gamePaused como true e mostrar o menu
                    }
                    // O cinto de inventário deve ser escondido APENAS se não for por causa da mochila
                    if (inventoryBeltElement && !pointerLockExitForBackpack) {
                        inventoryBeltElement.style.visibility = 'hidden';
                        inventoryBeltElement.style.opacity = '0';
                    }

                    // Lida com o estado de agachamento se o bloqueio do ponteiro for perdido
                    if (isCrouching) {
                        isCrouching = false;
                        playerBody.removeShape(originalPlayerShape);
                        playerBody.addShape(crouchPlayerShape);
                        playerBody.position.y += (originalPlayerShape.radius - crouchPlayerShape.radius);
                        cameraEyeLevelOffset = originalPlayerShape.radius;
                        playerBody.velocity.y = 0;
                        playerBody.wakeUp();
                    }
                }
                // Sempre reseta a flag após o processamento do pointerlockchange
                pointerLockExitForBackpack = false;
            });

            // NOVO: Listener de mousedown consolidado
            renderer.domElement.addEventListener('mousedown', (event) => {
                if (!isWorldReady || document.pointerLockElement !== renderer.domElement || gamePaused) return;

                mouseDownTime = performance.now();
                const primaryActionType = getActionType(beltItems[selectedSlotIndex]);

                if (event.button === 0) { // Clique esquerdo
                    if (primaryActionType === 'destroy') {
                        startDestruction();
                    } else if (primaryActionType === 'grab' || primaryActionType === 'dig') {
                        // Inicia o temporizador. Se for mantido, irá AGARRAR o objeto.
                        clickHoldTimer = setTimeout(() => {
                            if (primaryActionType === 'grab' && !pickedObjectBody) { // O clique longo só funciona para AGARRAR
                                grabObject();
                            }
                            // A escavação não tem ação de espera
                            clickHoldTimer = null; // O temporizador disparou
                        }, CLICK_HOLD_DURATION);
                    }
                } else if (event.button === 2) { // Clique direito
                    if (getActionType(beltItems[1]) === 'destroy') {
                        startDestruction();
                    }
                }
            });

            // NOVO: Listener de mouseup consolidado
            renderer.domElement.addEventListener('mouseup', (event) => {
                if (!isWorldReady || document.pointerLockElement !== renderer.domElement || gamePaused) return;

                stopDestruction(); // Para sempre a destruição em qualquer mouseup

                const primaryActionType = getActionType(beltItems[selectedSlotIndex]);
                const secondaryActionType = getActionType(beltItems[1]);

                if (event.button === 0) { // Botão esquerdo do mouse para cima
                    if (clickHoldTimer) { // Se o temporizador ainda existir, foi um clique curto
                        clearTimeout(clickHoldTimer);
                        clickHoldTimer = null;
                        if (primaryActionType === 'grab') {
                            if (pickedObjectBody) {
                                dropObject(); // Clique curto enquanto segura -> largar
                            } else {
                                collectObject(); // Clique curto enquanto não segura -> recolher
                            }
                        } else if (primaryActionType === 'dig') {
                            digHole(); // Ação de escavação no clique curto
                        }
                    }
                    // Se foi um clique longo, o temporizador é nulo e a função grabObject() já foi chamada.

                    if (primaryActionType === 'place') {
                        placeBlock(beltItems[selectedSlotIndex], selectedSlotIndex);
                    } else if (primaryActionType === 'apply_texture') {
                        applyTexture();
                    }
                } else if (event.button === 2) { // Botão direito do mouse para cima
                    if (secondaryActionType === 'place') {
                        placeBlock(beltItems[1], 1);
                    }
                }
            });

            // --- Funções Auxiliares para Ações do Jogador ---

            function getActionType(item) {
                if (item === null) return 'grab';
                if (item.name === axeItemName || item.name === hammerItemName || item.name === stoneItemName) return 'destroy';
                if (item.name === shovelItemName) return 'dig';
                if (item.name === textureApplicatorItemName) return 'apply_texture';
                if (item.name === cobItemName || item.name === floorItemName || item.name === treeSaplingItemName || item.name === woodenPlankItemName || item.name === treeTrunkItemName || item.name === boxItemName) return 'place';
                return null;
            }

            function startDestruction() {
                destructionComplete = false; // NOVO: Redefine a flag no início de uma nova destruição
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(scene.children, true);
                let target = null;
                destroyTargetDeposit = null; // Reseta no início
                for (let i = 0; i < intersects.length; i++) {
                    if (intersects[i].distance > destroyDistance) continue;
                    let intersectedObject = intersects[i].object;

                    // NOVO: Verifica se o objeto intersectado é um depósito de pedra ou terra
                    const dirtDeposit = dirtDeposits.find(d => d.domeMeshes.some(m => m.mesh === intersectedObject));
                    if (dirtDeposit && !dirtDeposit.flattened) {
                        target = { body: dirtDeposit.body, mesh: intersectedObject, patchObject: null };
                        destroyTargetDeposit = dirtDeposit;
                        break;
                    }

                    // Lógica de destruição de patch atualizada
                    if (intersectedObject.userData.patchObject) {
                        const patchObject = intersectedObject.userData.patchObject;
                        target = {
                            body: null, // Patches não têm corpo de física
                            mesh: intersectedObject, // A malha específica que foi atingida
                            patchObject: patchObject // O objeto principal do patch
                        };
                        break;
                    }

                    let mainObject = null, intersectedBody = null;
                    let currentObject = intersectedObject;
                    while (currentObject) {
                        if (currentObject.userData && currentObject.userData.physicsBody) {
                            mainObject = currentObject;
                            intersectedBody = currentObject.userData.physicsBody;
                            break;
                        }
                        currentObject = currentObject.parent;
                    }
                    if (mainObject && intersectedBody && intersectedBody.userData && intersectedBody.userData.isDestructible) {
                        target = { body: intersectedBody, mesh: mainObject };
                        break;
                    }
                }
                if (target) {
                    isDestroying = true;
                    destroyProgress = 0;
                    destroyTargetBody = target.body;
                    destroyTargetMesh = target.mesh;
                    destroyTargetPatchObject = target.patchObject || null;

                    if (destroyTargetDeposit) {
                        // O tempo de destruição agora é proporcional ao raio do depósito (ex: raio * 0.5)
                        targetDestroyTime = destroyTargetDeposit.radius * 0.5;
                        progressContainer.style.display = 'block';
                    } else {
                        let targetUserData;
                        if (destroyTargetPatchObject) {
                            targetUserData = destroyTargetPatchObject.userData;
                        } else if (destroyTargetBody) {
                            targetUserData = destroyTargetBody.userData;
                        }

                        if (targetUserData) {
                            targetDestroyTime = targetUserData.durability || 1.0;
                            progressContainer.style.display = 'block';
                        } else {
                            isDestroying = false; // Cancela se não houver dados do usuário
                        }
                    }
                }
            }

            function stopDestruction() {
                // Esta função agora apenas limpa o estado.
                // A lógica de parar a barra de progresso foi movida para o loop de animação.
                if (isDestroying) {
                    isDestroying = false;
                    destroyProgress = 0;
                    progressContainer.style.display = 'none';
                }
                // Limpa os alvos apenas quando o botão do mouse é solto ou a mira é perdida.
                destroyTargetBody = null;
                destroyTargetMesh = null;
                destroyTargetPatchObject = null;
                destroyTargetDeposit = null; // Reseta o depósito alvo
                destructionComplete = false; // Garante que a flag seja redefinida
            }

            function collectObject() {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(scene.children, true);
                for (const intersect of intersects) {
                    if (intersect.distance > pickUpDistance) continue;

                    const clickedBody = intersect.object.userData.physicsBody;
                    if (!clickedBody || !clickedBody.userData.isCollectible || clickedBody.userData.type !== boxItemName) continue;

                    // Encontra o índice da caixa na nossa lista de rastreamento
                    const boxIndex = collectibleBoxes.findIndex(box => box.body === clickedBody);
                    if (boxIndex > -1) {
                        const boxToRemove = collectibleBoxes[boxIndex];

                        // Remove o corpo do mundo da física
                        world.removeBody(boxToRemove.body);

                        // Remove todas as malhas visuais da cena
                        boxToRemove.meshes.forEach(m => scene.remove(m.mesh));

                        // Remove a caixa da nossa lista de rastreamento
                        collectibleBoxes.splice(boxIndex, 1);

                        // Adiciona o item ao inventário
                        addItemToInventory(backpackItems, { name: boxItemName, quantity: 1 });
                        updateBackpackDisplay();

                        break; // Sai do loop, pois já recolhemos um objeto
                    }
                }
            }

            function grabObject() {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(scene.children, true); // Search recursively
                const allPickableBodies = collectibleBoxes.map(b => b.body);

                for (let i = 0; i < intersects.length; i++) {
                    let body = intersects[i].object.userData.physicsBody;
                    if (body && allPickableBodies.includes(body)) {
                        if (intersects[i].distance <= pickUpDistance) {
                            pickedObjectBody = body;
                            pickedObjectMesh = intersects[i].object;
                            distanceToPickedObject = intersects[i].distance; // Store initial distance

                            // Make the object kinematic and disable collisions
                            pickedObjectBody.type = CANNON.Body.KINEMATIC;
                            pickedObjectBody.collisionResponse = false;

                            // Remove any existing constraints if they exist
                            if (grabberConstraint) {
                                world.removeConstraint(grabberConstraint);
                                grabberConstraint = null;
                            }
                            break; // Object grabbed, exit loop
                        }
                    }
                }
            }

            function dropObject() {
                if (!pickedObjectBody) return;

                // Restore the object to its original dynamic state
                pickedObjectBody.type = CANNON.Body.DYNAMIC;
                pickedObjectBody.collisionResponse = true;
                pickedObjectBody.wakeUp();

                // Give it a gentle push away from the player
                const throwDirection = new THREE.Vector3();
                camera.getWorldDirection(throwDirection);
                pickedObjectBody.velocity.copy(throwDirection.multiplyScalar(2)); // Apply a small impulse

                pickedObjectBody = null;
                pickedObjectMesh = null;
            }

            function placeBlock(item, slotIndex) {
                currentBlockType = item.name;
                if (ghostBlockMesh.visible && ghostBlockMesh.material.color.getHex() === 0x00ff00) {
                    if (item.quantity > 0) {
                        let materialLoaded = false;
                        if (currentBlockType === 'cob' && cobMaterialMesh) materialLoaded = true;
                        else if (currentBlockType === 'piso' && floorMaterialMesh) materialLoaded = true;
                        else if (currentBlockType === 'tábuas' && woodenPlankMaterialMesh) materialLoaded = true;
                        else if (currentBlockType === 'muda_arvore' && treeTrunkMaterialMesh && treeLeavesMaterialMesh) materialLoaded = true;
                        else if (currentBlockType === 'tronco_arvore' && treeTrunkMaterialMesh) materialLoaded = true;
                        else if (currentBlockType === boxItemName && cubeMaterialMesh) materialLoaded = true; // NOVO: Verifica o material da caixa

                        if (materialLoaded) {
                            if (currentBlockType === boxItemName) {
                                createBox(ghostBlockMesh.position, ghostBlockMesh.quaternion);
                            } else {
                                createPlaceableBlock(ghostBlockMesh.position, ghostBlockMesh.quaternion, currentBlockType);
                            }
                            item.quantity--;
                            if (item.quantity <= 0) {
                                if (slotIndex < beltItems.length) beltItems[slotIndex] = null;
                            }
                            updateBeltDisplay();
                            updateBackpackDisplay(); // Atualiza a mochila também, caso o item venha de lá
                        }
                    }
                }
            }

            function applyTexture() {
                if (!stoneMaterial) return;

                // Primeiro Raycast: para encontrar a posição aproximada e o objeto
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const groundMeshes = islandMeshes.map(item => item.mesh);
                const intersects = raycaster.intersectObjects(groundMeshes);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const hitPoint = intersect.point;
                    const patchSize = cobSize;

                    // Calcula a posição "desenrolada" (absoluta) e alinhada à grade
                    const unwrappedHitPointX = hitPoint.x + visualOffsetX;
                    const unwrappedHitPointZ = hitPoint.z + visualOffsetZ;
                    const snappedX = Math.round(unwrappedHitPointX / patchSize) * patchSize;
                    const snappedZ = Math.round(unwrappedHitPointZ / patchSize) * patchSize;

                    // Segundo Raycast (Física): para obter a normal e a altura exatas no centro da célula da grade
                    const rayFrom = new CANNON.Vec3(snappedX, islandSurfaceHeight + 10, snappedZ);
                    const rayTo = new CANNON.Vec3(snappedX, seabedLevel - 10, snappedZ);
                    const rayResult = new CANNON.RaycastResult();
                    world.raycastClosest(rayFrom, rayTo, { collisionFilterMask: 1 }, rayResult); // Apenas colide com o grupo padrão (terreno)

                    if (rayResult.hasHit) {
                        const preciseHitPoint = rayResult.hitPointWorld;
                        const preciseHitNormal = rayResult.hitNormalWorld;

                        // Impede a colocação de texturas debaixo d'água
                        if (preciseHitPoint.y < waterLevel) {
                            return;
                        }

                        // Calcula a rotação para alinhar o patch com a normal do terreno
                        const up = new CANNON.Vec3(0, 1, 0);
                        const quaternion = new CANNON.Quaternion();
                        quaternion.setFromVectors(up, preciseHitNormal);

                        const patchGeometry = new THREE.BoxGeometry(patchSize, 0.01, patchSize);
                        const patchMeshes = [];
                        const patchObject = {
                            position: preciseHitPoint.vadd(preciseHitNormal.scale(0.005)), // Posição com um ligeiro deslocamento
                            quaternion: quaternion, // Armazena a rotação
                            meshes: patchMeshes,
                            userData: { isDestructible: true, durability: 0.5, type: 'patch' }
                        };

                        for (let i = -Math.floor(numTiles / 2); i <= Math.floor(numTiles / 2); i++) {
                            for (let j = -Math.floor(numTiles / 2); j <= Math.floor(numTiles / 2); j++) {
                                const mesh = new THREE.Mesh(patchGeometry, stoneMaterial);
                                mesh.receiveShadow = true;
                                mesh.userData.patchObject = patchObject;
                                scene.add(mesh);
                                patchMeshes.push({ mesh: mesh, offsetX: i * worldSize, offsetZ: j * worldSize });
                            }
                        }
                        texturePatches.push(patchObject);
                    }
                }
            }

            // Evento mousemove para rotação da câmera e rotação de objetos
            document.addEventListener('mousemove', (event) => {
                // Determine the primary tool for visual feedback
                const primaryToolForVisuals = beltItems[selectedSlotIndex]; // Usa o slot selecionado
                const isPrimaryToolPlacing = primaryToolForVisuals && (primaryToolForVisuals.name === cobItemName || primaryToolForVisuals.name === floorItemName || primaryToolForVisuals.name === treeSaplingItemName || primaryToolForVisuals.name === woodenPlankItemName || primaryToolForVisuals.name === treeTrunkItemName || primaryToolForVisuals.name === boxItemName);
                const isPrimaryToolGrabbing = primaryToolForVisuals === null; // Hand is active if slot 0 is null


                if (isDragging && !gamePaused) { // Processa o movimento do mouse apenas se o jogo não estiver pausado
                    const deltaX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                    const deltaY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                    // Verifica se o botão direito do mouse está pressionado (botão 2)
                    const isRightButtonPressed = (event.buttons & 2);

                    // Lógica de rotação do ghost block
                    if (isPrimaryToolPlacing && isRightButtonPressed) {
                        // Aumenta o multiplicador para tornar a rotação mais responsiva
                        ghostBlockRotationY += deltaX * 0.15; // Rotação horizontal

                        // Define o ângulo de snap (45 graus)
                        const snapAngle = Math.PI / 4; // 45 graus

                        // Arredonda ghostBlockRotationY para o múltiplo mais próximo de snapAngle
                        ghostBlockRotationY = Math.round(ghostBlockRotationY / snapAngle) * snapAngle;

                    }
                    // Lógica de rotação do objeto segurado
                    else if (pickedObjectBody && isRightButtonPressed && isPrimaryToolGrabbing) {
                        const rotationSpeed = 0.01; // Ajuste este valor para rotação mais rápida/lenta

                        // Obtém o quaternion atual do objeto selecionado
                        let currentQuaternion = new THREE.Quaternion().copy(pickedObjectBody.quaternion);

                        // Guinada (movimento horizontal) em torno do eixo Y local do objeto
                        const yawDeltaQuaternion = new THREE.Quaternion().setFromAxisAngle(
                            new THREE.Vector3(0, 1, 0), // Eixo Y local
                            -deltaX * rotationSpeed // Sinal invertido para rotação horizontal
                        );
                        currentQuaternion.multiply(yawDeltaQuaternion); // Pós-multiplica para rotação local

                        // Inclinação (movimento vertical) em torno do eixo X local do objeto
                        const pitchDeltaQuaternion = new THREE.Quaternion().setFromAxisAngle(
                            new THREE.Vector3(1, 0, 0), // Eixo X local
                            -deltaY * rotationSpeed // Sinal invertido para rotação vertical
                        );
                        currentQuaternion.multiply(pitchDeltaQuaternion); // Pós-multiplica para rotação local

                        // Aplica a nova rotação combinada ao corpo de física do objeto selecionado
                        pickedObjectBody.quaternion.copy(currentQuaternion);
                    }
                    // Lógica de rotação da câmera
                    else if (!isRightButtonPressed) { // Apenas gira a câmera se o botão direito NÃO estiver pressionado
                        camera.rotation.y -= deltaX * 0.005;
                        camera.rotation.x -= deltaY * 0.005;
                        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                        // Se o botão direito não estiver pressionado, reseta as rotações do ghost block
                        if (isPrimaryToolPlacing) {
                            ghostBlockRotationY = 0;
                            ghostBlockRotationX = 0;
                        }
                    }
                }
            });

            // Listener de evento para redimensionamento da janela
            window.addEventListener('resize', onWindowResize);

            // Listeners de eventos para os novos botões do menu
            document.getElementById('resumeButton').addEventListener('click', hideOptionsScreen);
            document.getElementById('exitGameButton').addEventListener('click', () => {
                location.reload(); // Recarrega a página para sair do jogo
            });

            // Adiciona o listener para o novo botão de ícone do menu
            if (menuIconButton) {
                menuIconButton.addEventListener('click', showOptionsScreen);
            }

            // Listeners para o botão da mochila
            document.getElementById('backpackButton').addEventListener('click', openBackpack);
            document.getElementById('closeBackpackButton').addEventListener('click', closeBackpack);

            // NOVO: Chama a função para configurar os depósitos de terra
            setupDirtDeposits();
        }

        // NOVO: Função separada para configurar os depósitos de terra
        const minDepositDistance = 180; // NOVO: Distância mínima entre os depósitos
        function setupDirtDeposits() {
            textureLoader.load(dirtDepositTextureURL, (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(4, 2); // Repete a textura na cúpula
                dirtDepositMaterial = new THREE.MeshStandardMaterial({ map: texture });

                const flatTexture = texture.clone();
                flatTexture.needsUpdate = true; // Importante ao clonar
                flatTexture.repeat.set(1, 1);
                flattenedDirtDepositMaterial = new THREE.MeshStandardMaterial({ map: flatTexture });

                // Gera os dados dos depósitos de terra
                let attempts = 0;
                const maxAttempts = numDirtDeposits * 20; // Limite de tentativas para evitar loop infinito

                while (dirtDeposits.length < numDirtDeposits && attempts < maxAttempts) {
                    attempts++;
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * (islandRadiusBottom + 50);
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;

                    let isValid = true;
                    // Verifica a distância dos depósitos de terra existentes
                    for (const existingDeposit of dirtDeposits) {
                        const dx = x - existingDeposit.x;
                        const dz = z - existingDeposit.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        if (distance < minDepositDistance) {
                            isValid = false;
                            break;
                        }
                    }

                    if (isValid) {
                        // Usa um raycast para encontrar a posição e a normal corretas no terreno
                        const rayFrom = new CANNON.Vec3(x, islandSurfaceHeight + 20, z);
                        const rayTo = new CANNON.Vec3(x, seabedLevel - 10, z);
                        const rayResult = new CANNON.RaycastResult();
                        world.raycastClosest(rayFrom, rayTo, {}, rayResult);

                        if (rayResult.hasHit) {
                            const hitPoint = rayResult.hitPointWorld;
                            // SÓ SPAWNA SE ESTIVER ACIMA DO NÍVEL DO MAR
                            if (hitPoint.y < waterLevel) {
                                continue; // Pula para a próxima tentativa
                            }
                            const hitNormal = rayResult.hitNormalWorld;

                            // Cria um quaternion para alinhar o depósito com a normal do terreno
                            const up = new CANNON.Vec3(0, 1, 0);
                            const quaternion = new CANNON.Quaternion();
                            quaternion.setFromVectors(up, hitNormal);

                            const sizeFactor = 0.3 + Math.random() * 1.7; // Usa o mesmo fator de aleatorização da pedra
                            const depositRadius = dirtDepositRadius * sizeFactor;
                            const depositHeight = dirtDepositHeight * sizeFactor;

                            const coneGeometry = new THREE.ConeGeometry(depositRadius, depositHeight, 16);
                            const coneMesh = new THREE.Mesh(coneGeometry, dirtDepositMaterial);
                            coneMesh.castShadow = true;
                            coneMesh.receiveShadow = true;

                            const depositMeshes = [];
                            for (let j = -Math.floor(numTiles / 2); j <= Math.floor(numTiles / 2); j++) {
                                for (let k = -Math.floor(numTiles / 2); k <= Math.floor(numTiles / 2); k++) {
                                    const mesh = coneMesh.clone();
                                    scene.add(mesh);
                                    depositMeshes.push({ mesh: mesh, offsetX: j * worldSize, offsetZ: k * worldSize });
                                }
                            }

                            const cylinderShape = new CANNON.Cylinder(depositRadius, depositRadius, depositHeight, 16);
                            const cylinderBody = new CANNON.Body({
                                mass: 0,
                                type: CANNON.Body.STATIC,
                                material: islandMaterial
                            });
                            cylinderBody.addShape(cylinderShape); // Shape is centered on the body

                            // Position the body so its base is at the hit point
                            const bodyPosition = hitPoint.clone();
                            bodyPosition.y += depositHeight / 2;
                            cylinderBody.position.copy(bodyPosition);

                            cylinderBody.quaternion.copy(quaternion);
                            world.addBody(cylinderBody);

                            dirtDeposits.push({
                                x: hitPoint.x, z: hitPoint.z, y: hitPoint.y,
                                radius: depositRadius,
                                height: depositHeight,
                                flattened: false,
                                regenerationTimer: 0,
                                domeMeshes: depositMeshes, // Renomeado para depositMeshes
                                flattenedMeshes: [],
                                body: cylinderBody, // Usa o corpo do cilindro
                                type: 'dirt' // NOVO: Identificador de tipo
                            });
                        }
                    }
                }

                if (attempts >= maxAttempts) {
                    console.warn(`Não foi possível colocar todos os depósitos de terra. Apenas ${dirtDeposits.length}/${numDirtDeposits} foram colocados.`);
                }
            }, undefined, (error) => {
                console.error("Falha ao carregar a textura do depósito de terra:", error);
            });
        }

        // Função para lidar com o redimensionamento da janela
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Função para aplicar o efeito de envolvimento a um corpo de física (não retorna delta)
        function wrapObject(body, size) {
            if (body.position.x > size / 2) {
                body.position.x -= size;
            } else if (body.position.x < -size / 2) {
                body.position.x += size;
            }

            if (body.position.z > size / 2) {
                body.position.z -= size;
            } else if (body.position.z < -size / 2) {
                body.position.z += size;
            }
        }

        // Função para atualizar as posições de todas as malhas visuais para um dado corpo de cubo/bloco
        function updateObjectVisuals(body, meshesArray, visualOffsetX, visualOffsetZ) {
            meshesArray.forEach(item => { // item is now { mesh: THREE.Mesh | THREE.Group, offsetX, offsetZ }
                const visualObject = item.mesh; // This is the THREE.Group or a single Mesh
                visualObject.position.x = body.position.x + item.offsetX - visualOffsetX;
                visualObject.position.y = body.position.y;
                visualObject.position.z = body.position.z + item.offsetZ - visualOffsetZ;
                visualObject.quaternion.copy(body.quaternion); // Apply the body's rotation to the group/mesh
            });
        }

        // NOVO: Função para calcular a distância em um mundo que se envolve (toroidal)
        function calculateWrappedDistance(pos1, pos2) {
            const dx = Math.abs(pos1.x - pos2.x);
            const dy = Math.abs(pos1.y - pos2.y); // O eixo Y não se envolve
            const dz = Math.abs(pos1.z - pos2.z);

            const wrappedDx = Math.min(dx, worldSize - dx);
            const wrappedDz = Math.min(dz, worldSize - dz);

            return Math.sqrt(wrappedDx * wrappedDx + dy * dy + wrappedDz * wrappedDz);
        }

        // Loop principal de animação do jogo
        function animate() {
            requestAnimationFrame(animate);

            if (gamePaused) {
                // Se o jogo estiver pausado, apenas renderiza a cena, não atualiza a física ou o movimento do jogador
                renderer.render(scene, camera);
                return;
            }

            // Lógica de destruição progressiva
            // NOVO: A lógica só continua se a destruição estiver em andamento E não estiver completa.
            if (isDestroying && !destructionComplete) {
                // --- Verificação de mira atualizada ---
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(scene.children, true);

                let stillOnTarget = false;
                if (intersects.length > 0 && intersects[0].distance <= destroyDistance) {
                    let intersectedObject = intersects[0].object;

                    if (destroyTargetPatchObject) {
                        // Se estivermos destruindo um patch, verifica se a malha atingida pertence ao patch
                        if (intersectedObject.userData.patchObject === destroyTargetPatchObject) {
                            stillOnTarget = true;
                        }
                    } else if (destroyTargetDeposit) { // NOVO: Verifica se o depósito é o alvo
                        const deposit = dirtDeposits.find(d => d.domeMeshes.some(m => m.mesh === intersectedObject));
                        if (deposit && deposit === destroyTargetDeposit) {
                            stillOnTarget = true;
                        }
                    } else if (destroyTargetMesh) {
                        // Se estivermos destruindo um bloco, faz a verificação normal
                        let currentObject = intersectedObject;
                        while (currentObject) {
                            if (currentObject === destroyTargetMesh) {
                                stillOnTarget = true;
                                break;
                            }
                            currentObject = currentObject.parent;
                        }
                    }
                }

                // Se não estiver mais na mira, para tudo.
                // A função stopDestruction agora limpa todas as variáveis de estado.
                if (!stillOnTarget) {
                    stopDestruction();
                } else {
                    // Se estiver na mira, continua o progresso
                    destroyProgress += 1 / 60;
                    if (destroyProgress >= targetDestroyTime) {
                        // Objeto destruído!
                        let position;

                        // NOVO: Lógica de destruição de depósitos de pedra
                        if (destroyTargetDeposit) {
                            position = new THREE.Vector3(destroyTargetDeposit.x, destroyTargetDeposit.y, destroyTargetDeposit.z);
                            destroyTargetDeposit.flattened = true;
                            destroyTargetDeposit.regenerationTimer = 60; // Inicia o temporizador de 1 minuto

                            // Remove o corpo de física principal
                            if (destroyTargetDeposit.body) {
                                world.removeBody(destroyTargetDeposit.body);
                            }

                            const flattenedHeight = 0.2;
                            const flattenedGeometry = new THREE.CylinderGeometry(destroyTargetDeposit.radius, destroyTargetDeposit.radius, flattenedHeight, 16);
                            // NOVO: Usa o material correto (pedra ou terra) para o estado achatado
                            const flattenedMesh = new THREE.Mesh(flattenedGeometry, flattenedDirtDepositMaterial);
                            flattenedMesh.receiveShadow = true;

                            // Cria um novo corpo de física para o estado achatado, alinhado com o terreno
                            const flattenedShape = new CANNON.Cylinder(destroyTargetDeposit.radius, destroyTargetDeposit.radius, flattenedHeight, 16);
                            const flattenedBody = new CANNON.Body({
                                mass: 0,
                                type: CANNON.Body.STATIC,
                                shape: flattenedShape,
                                material: islandMaterial
                            });
                            const normal = new CANNON.Vec3(0, 1, 0);
                            const worldNormal = destroyTargetDeposit.body.quaternion.vmult(normal);
                            const offset = worldNormal.scale(0.01); // 1cm offset
                            flattenedBody.position.copy(destroyTargetDeposit.body.position.vadd(offset));
                            flattenedBody.quaternion.copy(destroyTargetDeposit.body.quaternion);
                            world.addBody(flattenedBody);
                            destroyTargetDeposit.flattenedBody = flattenedBody;


                            for (let j = -Math.floor(numTiles / 2); j <= Math.floor(numTiles / 2); j++) {
                                for (let k = -Math.floor(numTiles / 2); k <= Math.floor(numTiles / 2); k++) {
                                    const mesh = flattenedMesh.clone();
                                    scene.add(mesh);
                                    destroyTargetDeposit.flattenedMeshes.push({ mesh: mesh, offsetX: j * worldSize, offsetZ: k * worldSize });
                                }
                            }
                            // O rendimento da pedra agora é proporcional ao raio do depósito (ex: arredondado para o inteiro mais próximo)
                            if (destroyTargetDeposit.type === 'dirt') {
                                const dirtYield = Math.round(destroyTargetDeposit.radius * 1.5);
                                addItemToInventory(backpackItems, { name: dirtItemName, quantity: dirtYield });
                            }
                            updateBackpackDisplay();
                        }
                        // Lida com a destruição de patches
                        else if (destroyTargetPatchObject) {
                            position = destroyTargetPatchObject.position.clone();
                            const patchIndex = texturePatches.indexOf(destroyTargetPatchObject);
                            if (patchIndex > -1) {
                                texturePatches.splice(patchIndex, 1);
                            }
                            destroyTargetPatchObject.meshes.forEach(m => {
                                scene.remove(m.mesh);
                                if (m.mesh.geometry) m.mesh.geometry.dispose();
                            });
                            addItemToInventory(backpackItems, { name: stoneItemName, quantity: 1 });
                            updateBackpackDisplay();
                        }
                        // Handle regular block destruction
                        else if (destroyTargetBody) {
                            position = destroyTargetMesh.position.clone();
                            const bodyIndex = placedConstructionBodies.indexOf(destroyTargetBody);
                            if (bodyIndex !== -1) {
                               // Adiciona a lógica de recompensa de troncos com base no estágio da árvore
                               if (destroyTargetBody.userData.growthStage === 'media') {
                                   addItemToInventory(backpackItems, { name: treeTrunkItemName, quantity: 1 });
                               } else if (destroyTargetBody.userData.growthStage === 'arvore_adulta') {
                                   addItemToInventory(backpackItems, { name: treeTrunkItemName, quantity: 3 });
                               }
                               // Adiciona tábuas de madeira ao inventário se o objeto destruído for um tronco ou tábua
                               else if (destroyTargetBody.userData.type === 'tronco_arvore' || destroyTargetBody.userData.type === 'tábuas') {
                                   addItemToInventory(backpackItems, { name: woodenPlankItemName, quantity: 2 });
                               }
                               // Adiciona o item original ao inventário ao destruir
                               if (destroyTargetBody.userData.type === 'cob' || destroyTargetBody.userData.type === 'piso') {
                                   addItemToInventory(backpackItems, { name: destroyTargetBody.userData.type, quantity: 1 });
                               }
                               updateBackpackDisplay();

                               world.removeBody(destroyTargetBody);
                               placedConstructionBodies.splice(bodyIndex, 1);
                               scene.remove(destroyTargetMesh);
                               if (destroyTargetMesh.isGroup) {
                                   destroyTargetMesh.children.forEach(child => {
                                       if (child.geometry) child.geometry.dispose();
                                   });
                               } else if (destroyTargetMesh.geometry) {
                                   destroyTargetMesh.geometry.dispose();
                               }
                               placedConstructionMeshesArrays.splice(bodyIndex, 1);
                            }
                        }

                        if (position) {
                            createSmokeEffect(position);
                        }
                        destructionComplete = true; // A destruição está completa!
                        isDestroying = false; // Para a barra de progresso
                        progressContainer.style.display = 'none'; // Esconde a barra de progresso

                    } else {
                        // Atualiza a barra de progresso
                        progressBar.style.width = `${(destroyProgress / targetDestroyTime) * 100}%`;
                    }
                }
            } else {
                 // Reseta a barra de progresso se o usuário parar de destruir
                // NOVO: Agora só chama stopDestruction se a destruição NÃO foi concluída com sucesso.
                if (isDestroying && !destructionComplete) {
                    stopDestruction();
                }
                if (progressBar.style.width !== '0%') {
                    progressBar.style.width = '0%';
                }
            }


            // Define currentPlayerRadius no início da função animate
            const currentPlayerRadius = isCrouching ? crouchRadius : playerRadius;

            // Atualiza o mundo da física
            world.step(1 / 60);

            // NOVO: Lógica de regeneração dos depósitos de terra
            dirtDeposits.forEach(deposit => {
                if (deposit.flattened && deposit.regenerationTimer > 0) {
                    deposit.regenerationTimer -= 1 / 60; // Subtrai o tempo do frame
                    if (deposit.regenerationTimer <= 0) {
                        deposit.flattened = false;
                        if (deposit.flattenedBody) {
                            world.removeBody(deposit.flattenedBody);
                            deposit.flattenedBody = null;
                        }
                        if (deposit.body) {
                            world.addBody(deposit.body);
                        }
                        deposit.flattenedMeshes.forEach(item => {
                            scene.remove(item.mesh);
                            if (item.mesh.geometry) item.mesh.geometry.dispose();
                        });
                        deposit.flattenedMeshes = [];
                        deposit.domeMeshes.forEach(item => item.mesh.visible = true);
                    }
                }
            });

            // Lógica para os cubos e blocos: sempre dinâmicos e com massa original, a menos que sejam segurados
            // Apenas os cubos são pickable agora
            const allPickableBodies = collectibleBoxes.map(b => b.body);
            const allStaticBodies = [...placedConstructionBodies]; // Apenas blocos colocados são estáticos

            allPickableBodies.forEach(body => {
                // Ignora o objeto que está sendo segurado
                if (body === pickedObjectBody) {
                    return;
                }
                // Cubos devem ser dinâmicos quando não estão sendo pegos
                body.mass = body.userData.originalMass;
                body.type = CANNON.Body.DYNAMIC;
                body.allowSleep = true; // Permite que cubos "durmam" para otimização
                body.wakeUp(); // Garante que esteja ativo se houver movimento
                body.collisionResponse = true; // Garante que a resposta de colisão esteja sempre ativada
            });

            allStaticBodies.forEach(body => {
                // Blocos (apenas os colocados) devem ser estáticos
                body.mass = 0;
                body.type = CANNON.Body.STATIC;
                body.allowSleep = false; // Mantém ativo para colisão, mas não se move por física
                body.collisionResponse = true; // Garante que a resposta de colisão esteja sempre ativada
            });

            // Calcula o offset da "origem visual" para toda a grade de tiles
            // ANTES de envolver as posições. Isso é crucial para o efeito de mundo contínuo.
            const playerX = playerBody.position.x;
            const playerZ = playerBody.position.z;
            visualOffsetX = Math.round(playerX / worldSize) * worldSize;
            visualOffsetZ = Math.round(playerZ / worldSize) * worldSize;

            // Aplica o envolvimento ao corpo de física do jogador
            wrapObject(playerBody, worldSize);

            // Aplica o envolvimento aos corpos de física dos cubos e blocos
            [...allPickableBodies, ...allStaticBodies].forEach(body => {
                if (body !== pickedObjectBody) { // Apenas se não estiver sendo segurado
                    wrapObject(body, worldSize);
                }
            });

            // Atualiza as posições das malhas do terreno com base na posição envolvida do jogador
            islandMeshes.forEach(tile => {
                tile.mesh.position.x = tile.offsetX - visualOffsetX;
                tile.mesh.position.y = 0; // O plano está agora centrado em Y=0
                tile.mesh.position.z = tile.offsetZ - visualOffsetZ;
                // A rotação da malha é definida uma vez na inicialização e não precisa de ser atualizada.
            });
            // A rua foi removida, então não há necessidade de atualizar roadMeshes.

            // NOVO: Atualiza as posições das malhas de água para o efeito de envolvimento
            waterMeshes.forEach(tile => {
                tile.mesh.position.x = tile.offsetX - visualOffsetX;
                tile.mesh.position.z = tile.offsetZ - visualOffsetZ;
                // A posição Y é estática, por isso não precisa de ser atualizada no loop.
            });

            // NOVO: Atualiza as posições das malhas do fundo do mar para o efeito de envolvimento
            seabedMeshes.forEach(tile => {
                tile.mesh.position.x = tile.offsetX - visualOffsetX;
                tile.mesh.position.z = tile.offsetZ - visualOffsetZ;
                // A posição Y é estática, por isso não precisa de ser atualizada no loop.
            });

            // Atualiza as posições de todas as malhas visuais dos cubos/caixas
            collectibleBoxes.forEach(box => {
                // Primeiro, atualiza as posições de todas as malhas para lidar com o envolvimento do mundo,
                // garantindo que o efeito de mundo infinito funcione corretamente.
                updateObjectVisuals(box.body, box.meshes, visualOffsetX, visualOffsetZ);

                // Em seguida, itera sobre cada malha individual para verificar se ela está dentro
                // da distância de renderização da câmera. Isso corrige o problema de objetos
                // distantes aparecerem no horizonte.
                box.meshes.forEach(m => {
                    const distance = camera.position.distanceTo(m.mesh.position);
                    m.mesh.visible = distance <= renderDistance;
                });
            });



            // Atualiza as posições de todas as malhas visuais dos blocos colocados
            placedConstructionBodies.forEach((body, index) => {
                const meshesArray = placedConstructionMeshesArrays[index];

                // Primeiro, atualiza as posições de todas as malhas para lidar com o envolvimento do mundo.
                updateObjectVisuals(body, meshesArray, visualOffsetX, visualOffsetZ);

                // Em seguida, itera sobre cada malha individual para verificar a distância e definir a visibilidade.
                meshesArray.forEach(m => {
                    const distance = camera.position.distanceTo(m.mesh.position);
                    m.mesh.visible = distance <= renderDistance;
                });
            });

            // NOVO: Atualiza a posição e visibilidade dos domos dos buracos
            holeDomes.forEach(dome => {
                const distance = calculateWrappedDistance(playerBody.position, dome.position);
                const isVisible = distance <= renderDistance;

                dome.meshes.forEach(item => {
                    item.mesh.visible = isVisible;
                    if (isVisible) {
                        const visualObject = item.mesh;
                        visualObject.position.x = dome.position.x + item.offsetX - visualOffsetX;
                        visualObject.position.y = dome.position.y;
                        visualObject.position.z = dome.position.z + item.offsetZ - visualOffsetZ;
                    }
                });
            });

            texturePatches.forEach(patch => {
                const distance = calculateWrappedDistance(playerBody.position, patch.position);
                const isVisible = distance <= renderDistance;

                patch.meshes.forEach(item => {
                    item.mesh.visible = isVisible;
                    if (isVisible) {
                        const visualObject = item.mesh;
                        visualObject.position.x = patch.position.x + item.offsetX - visualOffsetX;
                        visualObject.position.y = patch.position.y;
                        visualObject.position.z = patch.position.z + item.offsetZ - visualOffsetZ;
                        if (patch.quaternion) {
                            visualObject.quaternion.copy(patch.quaternion);
                        }
                    }
                });
            });

            // NOVO: Atualiza a posição e visibilidade dos depósitos de terra
            dirtDeposits.forEach(deposit => {
                const depositPosition = new THREE.Vector3(deposit.x, deposit.y, deposit.z);
                const distance = calculateWrappedDistance(playerBody.position, depositPosition);
                const isVisible = distance <= renderDistance;

                // Atualiza as malhas da cúpula
                deposit.domeMeshes.forEach(item => {
                    item.mesh.visible = isVisible && !deposit.flattened;
                    if (item.mesh.visible) {
                        item.mesh.position.set(
                            deposit.body.position.x + item.offsetX - visualOffsetX,
                            deposit.body.position.y,
                            deposit.body.position.z + item.offsetZ - visualOffsetZ
                        );
                        item.mesh.quaternion.copy(deposit.body.quaternion);
                    }
                });

                // Atualiza as malhas do estado achatado
                deposit.flattenedMeshes.forEach(item => {
                    item.mesh.visible = isVisible && deposit.flattened;
                    if (item.mesh.visible) {
                        item.mesh.position.set(
                            deposit.flattenedBody.position.x + item.offsetX - visualOffsetX,
                            deposit.flattenedBody.position.y,
                            deposit.flattenedBody.position.z + item.offsetZ - visualOffsetZ
                        );
                        item.mesh.quaternion.copy(deposit.flattenedBody.quaternion);
                    }
                });
            });


            // Se um objeto estiver sendo segurado, atualiza sua posição para ficar na frente da câmera
            if (pickedObjectBody) {
                const targetPosition = new THREE.Vector3();
                camera.getWorldDirection(targetPosition);
                targetPosition.multiplyScalar(distanceToPickedObject); // Usa a distância inicial armazenada
                targetPosition.add(camera.position);

                // Define a posição do corpo cinemático diretamente
                pickedObjectBody.position.copy(targetPosition);
                // Zera as velocidades para evitar qualquer movimento residual indesejado
                pickedObjectBody.velocity.set(0, 0, 0);
                pickedObjectBody.angularVelocity.set(0, 0, 0);
            }

            // Determine the primary tool for visual feedback and ghost block logic
            const primaryTool = beltItems[selectedSlotIndex]; // Usa o slot selecionado
            // Declaração única das variáveis
            let isPrimaryToolPlacing = false;
            let isPrimaryToolDestroying = false;
            let isPrimaryToolGrabbing = false;

            if (primaryTool === null) { // Se o slot selecionado estiver vazio, a "mão" está ativa
                isPrimaryToolGrabbing = true;
            } else if (primaryTool.name === axeItemName || primaryTool.name === hammerItemName || primaryTool.name === stoneItemName) {
                isPrimaryToolDestroying = true;
            } else if (primaryTool.name === cobItemName || primaryTool.name === floorItemName || primaryTool.name === treeSaplingItemName || primaryTool.name === woodenPlankItemName || primaryTool.name === treeTrunkItemName || primaryTool.name === boxItemName) {
                isPrimaryToolPlacing = true;
                currentBlockType = primaryTool.name; // Define o tipo de bloco para o ghost mesh
            }


            // Lógica do ghost block para colocação e snapping
            if (ghostBlockMesh) {
                if (isPrimaryToolPlacing && !gamePaused) {
                    ghostBlockMesh.visible = true; // Garante que o ghost block esteja visível

                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(scene.children);

                    let canPlace = false; // Declarar canPlace aqui
                    let placementPosition = new THREE.Vector3();
                    let tempPlacementQuaternion = new THREE.Quaternion(); // Usar um quaternion temporário

                    // A rotação manual agora é apenas em torno do eixo Y
                    const manualRotationQuaternion = new THREE.Quaternion().setFromEuler(
                        new THREE.Euler(0, ghostBlockRotationY, 0, 'YXZ')
                    );

                    // Define as dimensões do bloco atual para o ghost mesh
                    let currentGhostWidth, currentGhostHeight, currentGhostDepth;
                    if (currentBlockType === 'cob') {
                        currentGhostWidth = cobWidth;
                        currentGhostHeight = cobHeight;
                        currentGhostDepth = cobDepth;
                        ghostBlockMesh.geometry = new THREE.BoxGeometry(currentGhostWidth, currentGhostHeight, currentGhostDepth);
                    } else if (currentBlockType === 'piso') {
                        currentGhostWidth = floorWidth;
                        currentGhostHeight = floorHeight;
                        currentGhostDepth = floorDepth;
                        ghostBlockMesh.geometry = new THREE.BoxGeometry(currentGhostWidth, currentGhostHeight, currentGhostDepth);
                    } else if (currentBlockType === 'tábuas') {
                        currentGhostWidth = woodenPlankWidth;
                        currentGhostHeight = woodenPlankHeight;
                        currentGhostDepth = woodenPlankDepth;
                        ghostBlockMesh.geometry = new THREE.BoxGeometry(currentGhostWidth, currentGhostHeight, currentGhostDepth);
                    } else if (currentBlockType === 'muda_arvore') {
                        // O ghost block para 'muda_arvore' deve corresponder ao estágio inicial 'semente'
                        const seedBaseData = treeStages['semente'];
                        currentGhostWidth = seedBaseData.visual.sphere.radius * 2;
                        currentGhostDepth = seedBaseData.visual.sphere.radius * 2;
                        currentGhostHeight = seedBaseData.visual.sphere.radius * 2;
                        // A geometria do ghost block é agora uma esfera
                        ghostBlockMesh.geometry = new THREE.SphereGeometry(seedBaseData.visual.sphere.radius, 8, 8);
                    } else if (currentBlockType === 'tronco_arvore') { // NOVO: Geometria do ghost para tronco
                        currentGhostWidth = trunkRadius * 2;
                        currentGhostHeight = trunkHeight;
                        currentGhostDepth = trunkRadius * 2;
                        ghostBlockMesh.geometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius, trunkHeight, trunkSegments);
                    } else if (currentBlockType === boxItemName) {
                        currentGhostWidth = 1;
                        currentGhostHeight = 1;
                        currentGhostDepth = 1;
                        ghostBlockMesh.geometry = new THREE.BoxGeometry(currentGhostWidth, currentGhostHeight, currentGhostDepth);
                    }
                    // Update ghost block geometry
                    // ghostBlockMesh.geometry = new THREE.BoxGeometry(currentGhostWidth, currentGhostHeight, currentGhostDepth); // Removido para lidar individualmente


                    // Lista de todos os corpos que podem ser base para colocação
                    const allPlaceableSurfaces = [islandBody, ...placedConstructionBodies];

                    for (let i = 0; i < intersects.length; i++) {
                        const intersectedObject = intersects[i].object;
                        const intersectedBody = intersectedObject.userData.physicsBody;

                        if (intersectedObject.userData.isWater) {
                            continue; // Pula a água, não pode construir nela
                        }

                        if (intersectedBody && allPlaceableSurfaces.includes(intersectedBody)) {
                            // Verifica a distância máxima para colocação
                            if (intersects[i].distance <= pickUpDistance + 1) { // Um pouco mais longe que pegar
                                const hitPoint = intersects[i].point;

                                // NOVO: Verifica se o ponto de impacto está dentro do volume de um depósito de pedra
                                let isOnDirtDepositArea = false;
                                for (const deposit of dirtDeposits) {
                                    const depositPosition = new THREE.Vector3().copy(deposit.body.position);
                                    // A verificação agora é uma simples distância 3D
                                    if (hitPoint.distanceTo(depositPosition) < deposit.radius) {
                                        isOnDirtDepositArea = true;
                                        break;
                                    }
                                }

                                if (isOnDirtDepositArea) {
                                    continue; // Pula para o próximo objeto intersectado, impedindo a colocação
                                }


                                const hitNormal = intersects[i].face.normal.clone().transformDirection(intersectedObject.matrixWorld).normalize();

                                // Calcula a posição do centro do bloco acima da superfície
                                let basePosition = new THREE.Vector3().copy(hitPoint);
                                basePosition.add(hitNormal.multiplyScalar(currentGhostHeight / 2));

                                // NOVO: Alinhamento da grade
                                // Calcula a posição "desenrolada" (absoluta)
                                const unwrappedX = basePosition.x + visualOffsetX;
                                const unwrappedZ = basePosition.z + visualOffsetZ;
                                // Alinha na grade
                                const snappedUnwrappedX = Math.round(unwrappedX / cobSize) * cobSize;
                                const snappedUnwrappedZ = Math.round(unwrappedZ / cobSize) * cobSize;
                                // Converte de volta para as coordenadas do mundo visível
                                placementPosition.x = snappedUnwrappedX - visualOffsetX;
                                placementPosition.z = snappedUnwrappedZ - visualOffsetZ;

                                // NOVO: Alinha a posição Y na grade, considerando a altura da superfície da ilha como a base.
                                // Isso garante que os blocos se encaixem verticalmente.
                                const n_y = Math.round((basePosition.y - islandSurfaceHeight) / currentGhostHeight - 0.5);
                                placementPosition.y = islandSurfaceHeight + (n_y + 0.5) * currentGhostHeight;


                                // A rotação agora é apenas a rotação manual, garantindo que o bloco fique sempre na vertical
                                tempPlacementQuaternion.copy(manualRotationQuaternion);

                                // Verifica se a posição do ghost block não colide com o jogador
                                const playerPos = new THREE.Vector3().copy(playerBody.position);
                                playerPos.y += currentPlayerRadius; // Centro da esfera do jogador

                                const distanceToPlayer = placementPosition.distanceTo(playerPos);
                                const minPlayerDistance = currentPlayerRadius + (currentGhostHeight / 2) + 0.1; // Raio do jogador + metade da altura do bloco + buffer

                                if (distanceToPlayer > minPlayerDistance) {
                                    canPlace = true;
                                    // Se for uma muda de árvore, verifica a distância das outras árvores
                                    if (currentBlockType === 'muda_arvore') {
                                        for (const existingBody of placedConstructionBodies) {
                                            // Verifica se o corpo existente é uma árvore em qualquer estágio de crescimento
                                            // (muda, media ou arvore_adulta)
                                            if (existingBody.userData.type === 'muda_arvore' || existingBody.userData.growthStage) {
                                                const existingTreePos = new THREE.Vector3().copy(existingBody.position);
                                                const distanceToExistingTree = placementPosition.distanceTo(existingTreePos);
                                                // AQUI: A regra para não colocar mudas perto de árvores grandes
                                                if (distanceToExistingTree < minTreePlacementDistance) {
                                                    canPlace = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (canPlace) {
                                        break; // Encontrou uma posição válida, sai do loop
                                    }
                                }
                            }
                        }
                    }

                    if (canPlace) {
                        ghostBlockMesh.position.copy(placementPosition);
                        ghostBlockMesh.quaternion.copy(tempPlacementQuaternion);
                        ghostBlockMesh.material.color.setHex(0x00ff00); // Verde para indicar que pode ser colocado
                    } else {
                        ghostBlockMesh.visible = true; // Mantém visível para mostrar a cor vermelha
                        ghostBlockMesh.material.color.setHex(0xff0000); // Vermelho para inválido
                        ghostBlockMesh.position.copy(placementPosition); // Mantém a posição para que o usuário saiba onde está tentando colocar
                        ghostBlockMesh.quaternion.copy(tempPlacementQuaternion); // Mantém a rotação
                    }
                } else {
                    ghostBlockMesh.visible = false; // Garante que o ghost block esteja oculto se não estiver no modo de colocação
                }
            }


            const playerBottomY = playerBody.position.y - (isCrouching ? crouchRadius : playerRadius);
            const isInWater = playerBottomY < waterLevel;

            // Lógica de agachamento e mergulho
            if (keysPressed['c']) {
                if (!isCrouching && !isInWater) { // Agachar em terra
                    isCrouching = true;
                    playerBody.removeShape(originalPlayerShape);
                    playerBody.addShape(crouchPlayerShape);
                    playerBody.position.y -= (playerRadius - crouchRadius);
                    cameraEyeLevelOffset = crouchRadius;
                    playerBody.velocity.y = 0;
                    playerBody.wakeUp();
                }
                // A lógica de mergulho (aplicar velocidade para baixo) é tratada na seção de física da água
            } else if (isCrouching) { // Levantar em terra
                isCrouching = false;
                playerBody.removeShape(crouchPlayerShape);
                playerBody.addShape(originalPlayerShape);
                playerBody.position.y += (playerRadius - crouchRadius);
                cameraEyeLevelOffset = playerRadius;
                playerBody.velocity.y = 0;
                playerBody.wakeUp();
            }

            // Atualiza a posição da câmera para a posição do corpo de física do jogador
            camera.position.copy(playerBody.position);
            camera.position.y += cameraEyeLevelOffset;

            // Lógica do efeito subaquático
            if (camera.position.y < waterLevel) {
                scene.background = underwaterColor;
                scene.fog = underwaterFog;
                ambientLight.color.setHex(0x004080); // Cor azulada para a luz ambiente
            } else {
                scene.background = skyColor;
                scene.fog = skyFog;
                ambientLight.color.setHex(0xffffff); // Cor branca padrão
            }

            // Atualiza a posição e o alvo da luz direcional para seguir a câmera/jogador
            directionalLight.position.copy(camera.position);
            directionalLight.position.x += 10;
            directionalLight.position.y += 15;
            directionalLight.position.z += 10;
            directionalLight.target.position.copy(camera.position);
            directionalLight.target.updateMatrixWorld();

            // Sincroniza a rotação horizontal do corpo do jogador com a rotação da câmera
            playerBody.quaternion.setFromEuler(0, camera.rotation.y, 0);

            // Lógica de movimento do jogador com base nas teclas pressionadas
            let currentMoveSpeed = walkSpeed;
            if (keysPressed['shift']) {
                currentMoveSpeed *= runSpeedMultiplier;
            }
            if (isCrouching) {
                currentMoveSpeed *= crouchSpeedMultiplier;
            }

            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            const movementVector = new THREE.Vector3(0, 0, 0);

            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

            // Lógica de física da água e mergulho
            if (isInWater && !isWaterJumping) {
                // Lógica de Mergulho: Se 'c' for pressionado, define uma velocidade para baixo
                if (keysPressed['c']) {
                    playerBody.velocity.y = -walkSpeed; // Mergulha com a velocidade de caminhada
                } else {
                    // --- Lógica de Flutuação Estável (quando não está a mergulhar ou a saltar da água) ---
                    const K_SPRING = 250;
                    const C_DAMPING = 35;
                    const gravityMagnitude = Math.abs(world.gravity.y);
                    const antiGravityForce = playerBody.mass * gravityMagnitude;
                    const targetY = waterLevel + (isCrouching ? crouchRadius : playerRadius); // Flutua na superfície
                    const displacement = playerBody.position.y - targetY;
                    const springForce = -K_SPRING * displacement;
                    const verticalVelocity = playerBody.velocity.y;
                    const dampingForce = -C_DAMPING * verticalVelocity;
                    const totalBuoyancyForce = antiGravityForce + springForce + dampingForce;
                    playerBody.applyForce(new CANNON.Vec3(0, totalBuoyancyForce, 0), playerBody.position);
                }

                // Aplica arrasto/resistência da água
                playerBody.velocity.x *= 0.90;
                playerBody.velocity.z *= 0.90;
                currentMoveSpeed *= 0.5;
            }


            if (keysPressed['w']) {
                movementVector.add(forward);
            }
            if (keysPressed['s']) {
                movementVector.sub(forward);
            }
            if (keysPressed['a']) {
                movementVector.sub(right);
            }
            if (keysPressed['d']) {
                movementVector.add(right);
            }

            if (movementVector.lengthSq() > 0) {
                const normalizedMovementVector = movementVector.clone().normalize();

                // Calculate desired velocity
                const desiredVelocity = new CANNON.Vec3(
                    normalizedMovementVector.x * currentMoveSpeed,
                    playerBody.velocity.y, // Maintain current vertical velocity
                    normalizedMovementVector.z * currentMoveSpeed
                );

                // Calculate velocity difference
                const velocityDifference = new CANNON.Vec3();
                desiredVelocity.vsub(playerBody.velocity, velocityDifference);

                // Apply impulse to reach desired velocity
                // Impulse = mass * velocity_difference
                const impulse = new CANNON.Vec3(
                    playerBody.mass * velocityDifference.x,
                    playerBody.mass * velocityDifference.y,
                    playerBody.mass * velocityDifference.z
                );
                playerBody.applyImpulse(impulse, playerBody.position);

                playerBody.allowSleep = false; // Player is moving, keep active
            } else {
                // If no movement keys are pressed, apply a small damping to stop horizontal movement
                playerBody.velocity.x *= 0.9;
                playerBody.velocity.z *= 0.9;
                // Allow the player to "sleep" (physics optimization) if stopped and not holding an object
                if (pickedObjectBody === null && Math.abs(playerBody.velocity.y) < 0.1) {
                    playerBody.allowSleep = true;
                } else {
                    playerBody.allowSleep = false; // Keep active if holding object or falling/jumping
                }
            }


            // Lógica de subida de degraus (mantida, mas pode precisar de ajustes finos com o novo movimento)
            const stepClimbHeight = 0.3;
            const rayLength = currentPlayerRadius + 0.1;

            const playerHorizontalForwardCannon = new CANNON.Vec3(playerBody.velocity.x, 0, playerBody.velocity.z);
            if (playerHorizontalForwardCannon.length() > 0) {
                playerHorizontalForwardCannon.normalize();
            }

            const rayOriginLow = new CANNON.Vec3(
                playerBody.position.x + playerHorizontalForwardCannon.x * rayLength,
                playerBody.position.y - currentPlayerRadius + 0.05, // Ajusta para a base da esfera
                playerBody.position.z + playerHorizontalForwardCannon.z * rayLength
            );
            const rayTargetLow = new CANNON.Vec3(
                rayOriginLow.x,
                rayOriginLow.y - 0.1,
                rayOriginLow.z
            );

            let hitLow = false;
            const rayResultStep = new CANNON.RaycastResult(); // Usar uma nova variável para evitar conflito
            // Verifica colisão com terreno (rua), estrada, cubos e blocos
            world.raycastAny(rayOriginLow, rayTargetLow, {}, rayResultStep);
            // A lista de corpos "chão" para subida de degraus
            const stepClimbGroundBodies = [islandBody, ...collectibleBoxes.map(b => b.body), ...placedConstructionBodies];
            if (rayResultStep.hasHit && stepClimbGroundBodies.includes(rayResultStep.body)) {
                hitLow = true;
            }

            const rayOriginHigh = new CANNON.Vec3(
                playerBody.position.x + playerHorizontalForwardCannon.x * rayLength,
                playerBody.position.y - currentPlayerRadius + stepClimbHeight + 0.05, // Ajusta para a base da esfera
                rayOriginLow.z + playerHorizontalForwardCannon.z * rayLength
            );
            const rayTargetHigh = new CANNON.Vec3(
                rayOriginHigh.x,
                rayOriginHigh.y - 0.1,
                rayOriginHigh.z
            );

            let hitHigh = false;
            rayResultStep.reset(); // Resetar para o próximo raycast
            world.raycastAny(rayOriginHigh, rayTargetHigh, {}, rayResultStep);
            if (rayResultStep.hasHit && stepClimbGroundBodies.includes(rayResultStep.body)) {
                hitHigh = true;
            }

            if (hitLow && !hitHigh && Math.abs(playerBody.velocity.y) < 0.1) {
                const obstacleHeight = rayOriginLow.y - rayResultStep.hitPointWorld.y;
                if (obstacleHeight > 0.01 && obstacleHeight <= stepClimbHeight) {
                    playerBody.velocity.y = 2;
                }
            }

            // Lógica de crescimento da muda de árvore
            for (let i = placedConstructionBodies.length - 1; i >= 0; i--) {
                const blockBody = placedConstructionBodies[i];
                const blockMeshArray = placedConstructionMeshesArrays[i];
                const treeGroup = blockMeshArray[0].mesh; // This is the THREE.Group

                if (blockBody.userData.type === 'muda_arvore' && !blockBody.userData.isFullyGrown) {
                    const currentGrowthStageName = blockBody.userData.growthStage;
                    const currentBaseStageData = treeStages[currentGrowthStageName];
                    const currentRandomizedData = blockBody.userData.randomizedDimensions;

                    let nextGrowthStageName = null;
                    if (currentGrowthStageName === 'semente' && world.time - blockBody.userData.growthStartTime >= currentBaseStageData.growthTime) {
                        nextGrowthStageName = 'muda';
                    } else if (currentGrowthStageName === 'muda' && world.time - blockBody.userData.growthStartTime >= currentBaseStageData.growthTime) {
                        nextGrowthStageName = 'media';
                    } else if (currentGrowthStageName === 'media' && world.time - blockBody.userData.growthStartTime >= currentBaseStageData.growthTime) {
                        nextGrowthStageName = 'arvore_adulta';
                    }

                    if (nextGrowthStageName) {
                        console.log(`Árvore crescendo de ${currentGrowthStageName} para ${nextGrowthStageName} no tempo do mundo: ${world.time.toFixed(2)}`);
                        const nextBaseStageData = treeStages[nextGrowthStageName];
                        const nextRandomizedData = randomizeTreeDimensions(nextBaseStageData);

                        const oldOverallPhysicsHeight = currentRandomizedData.overallPhysicsHeight;

                        while (blockBody.shapes.length > 0) {
                            blockBody.removeShape(blockBody.shapes[0]);
                        }

                        const trunkPhysics = nextRandomizedData.physics.trunk;
                        const trunkShape = new CANNON.Box(new CANNON.Vec3(trunkPhysics.width / 2, trunkPhysics.height / 2, trunkPhysics.depth / 2));
                        blockBody.addShape(trunkShape, new CANNON.Vec3(0, trunkPhysics.yOffset, 0));

                        const leavesPhysics = nextRandomizedData.physics.leaves;
                        if (leavesPhysics.width > 0) {
                            const leavesShape = new CANNON.Box(new CANNON.Vec3(leavesPhysics.width / 2, leavesPhysics.height / 2, leavesPhysics.depth / 2));
                            blockBody.addShape(leavesShape, new CANNON.Vec3(0, leavesPhysics.yOffset, 0));
                        }

                        const newOverallPhysicsHeight = nextRandomizedData.overallPhysicsHeight;
                        blockBody.position.y += (newOverallPhysicsHeight - oldOverallPhysicsHeight) / 2;

                        // Itera sobre cada malha visual espelhada para esta árvore para substituí-la
                        blockMeshArray.forEach(item => {
                            const oldVisualObject = item.mesh;

                            // Remove e descarta o objeto antigo da cena
                            if (oldVisualObject) {
                                if (oldVisualObject.isGroup) {
                                    oldVisualObject.children.forEach(child => {
                                        if (child.geometry) child.geometry.dispose();
                                        if (child.material) child.material.dispose();
                                    });
                                } else { // é uma Malha
                                    if (oldVisualObject.geometry) oldVisualObject.geometry.dispose();
                                    if (oldVisualObject.material) oldVisualObject.material.dispose();
                                }
                                scene.remove(oldVisualObject);
                            }

                            // Cria o novo objeto visual (sempre um grupo para estágios de árvore)
                            const newTreeGroup = new THREE.Group();
                            const trunkGeometry = new THREE.CylinderGeometry(nextRandomizedData.visual.trunk.radius, nextRandomizedData.visual.trunk.radius, nextRandomizedData.visual.trunk.height, 8);
                            const trunkMesh = new THREE.Mesh(trunkGeometry, treeTrunkMaterialMesh);
                            trunkMesh.position.y = nextRandomizedData.visual.trunk.yOffsetInGroup;
                            trunkMesh.castShadow = true;
                            trunkMesh.receiveShadow = true;
                            newTreeGroup.add(trunkMesh);

                            const leavesGeometry = new THREE.SphereGeometry(nextRandomizedData.visual.leaves.radius, 16, 16);
                            const leavesMesh = new THREE.Mesh(leavesGeometry, treeLeavesMaterialMesh);
                            leavesMesh.position.y = nextRandomizedData.visual.leaves.yOffsetInGroup;
                            leavesMesh.castShadow = true;
                            leavesMesh.receiveShadow = true;
                            newTreeGroup.add(leavesMesh);

                            newTreeGroup.userData.physicsBody = blockBody;
                            scene.add(newTreeGroup);

                            // Atualiza a referência no array para o novo objeto
                            item.mesh = newTreeGroup;
                        });

                        // Update userData
                        blockBody.userData.dimensions = {
                            width: nextRandomizedData.physics.trunk.width, // Store trunk width as a representative
                            height: newOverallPhysicsHeight, // Store the new overall height
                            depth: nextRandomizedData.physics.trunk.depth // Store trunk depth as a representative
                        };
                        blockBody.userData.growthStage = nextGrowthStageName;
                        blockBody.userData.growthStartTime = world.time;
                        blockBody.userData.randomizedDimensions = nextRandomizedData; // Update randomized dimensions

                        if (nextGrowthStageName === 'arvore_adulta') {
                            blockBody.userData.isFullyGrown = true;
                            console.log('Árvore totalmente crescida!');
                        }
                        blockBody.wakeUp(); // Ensure the body is active after shape changes
                    }
                }
            }


            // --- Lógica de mudança de cor da mira ---
            let crosshairColor = 'white'; // Cor padrão

            // Determine the active tool based on the left slot (primary action)
            const primaryToolForCrosshair = beltItems[selectedSlotIndex]; // Usa o slot selecionado
            // Declaração única das variáveis
            isPrimaryToolPlacing = false;
            let isPrimaryToolApplyingTexture = false;
            isPrimaryToolDestroying = false;
            isPrimaryToolGrabbing = false;

            if (primaryToolForCrosshair === null) { // Se o slot selecionado estiver vazio, a "mão" está ativa
                isPrimaryToolGrabbing = true;
            } else if (primaryToolForCrosshair.name === textureApplicatorItemName) {
                isPrimaryToolApplyingTexture = true;
            } else if (primaryToolForCrosshair.name === axeItemName || primaryToolForCrosshair.name === hammerItemName || primaryToolForCrosshair.name === stoneItemName) {
                isPrimaryToolDestroying = true;
            } else if (primaryToolForCrosshair.name === cobItemName || primaryToolForCrosshair.name === floorItemName || primaryToolForCrosshair.name === treeSaplingItemName || primaryToolForCrosshair.name === woodenPlankItemName || primaryToolForCrosshair.name === treeTrunkItemName || primaryToolForCrosshair.name === boxItemName) {
                isPrimaryToolPlacing = true;
                currentBlockType = primaryToolForCrosshair.name; // Define o tipo de bloco para o ghost mesh
            }

            // Adjust crosshair color based on validity for placing/destroying/grabbing
            if (document.pointerLockElement === renderer.domElement && !pickedObjectBody && !gamePaused) {
                if (isPrimaryToolPlacing) {
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(scene.children);
                    let canPlace = false; // Declarar canPlace aqui
                    let placementPosition = new THREE.Vector3();
                    let tempPlacementQuaternion = new THREE.Quaternion(); // Usar um quaternion temporário
                    let currentGhostHeight, currentGhostWidth, currentGhostDepth;

                    if (currentBlockType === 'cob') {
                        currentGhostWidth = cobWidth;
                        currentGhostHeight = cobHeight;
                        currentGhostDepth = cobDepth;
                    } else if (currentBlockType === 'piso') {
                        currentGhostWidth = floorWidth;
                        currentGhostHeight = floorHeight;
                        currentGhostDepth = floorDepth;
                    } else if (currentBlockType === 'tábuas') {
                        currentGhostWidth = woodenPlankWidth;
                        currentGhostHeight = woodenPlankHeight;
                        currentGhostDepth = woodenPlankDepth;
                    } else if (currentBlockType === 'muda_arvore') {
                        const seedBaseData = treeStages['semente'];
                        currentGhostWidth = seedBaseData.visual.sphere.radius * 2;
                        currentGhostDepth = seedBaseData.visual.sphere.radius * 2;
                        currentGhostHeight = seedBaseData.visual.sphere.radius * 2;
                    } else if (currentBlockType === 'tronco_arvore') { // NOVO: Altura do ghost para tronco
                        currentGhostWidth = trunkRadius * 2;
                        currentGhostHeight = trunkHeight;
                        currentGhostDepth = trunkRadius * 2;
                    } else if (currentBlockType === boxItemName) {
                        currentGhostWidth = 1;
                        currentGhostHeight = 1;
                        currentGhostDepth = 1;
                    }

                    for (let i = 0; i < intersects.length; i++) {
                        const intersectedObject = intersects[i].object;
                        if (intersectedObject.userData.isWater) continue; // Ignora a água

                        const intersectedBody = intersectedObject.userData.physicsBody;
                        const allPlaceableSurfaces = [islandBody, ...placedConstructionBodies];

                        if (intersectedBody && allPlaceableSurfaces.includes(intersectedBody)) {
                            if (intersects[i].distance <= pickUpDistance + 1) {
                                const hitPoint = intersects[i].point;

                                // NOVO: Adiciona a verificação da área do depósito de pedra à lógica da mira
                                let isOnDirtDepositArea = false;
                                for (const deposit of dirtDeposits) {
                                    const depositPosition = new THREE.Vector3().copy(deposit.body.position);
                                    if (hitPoint.distanceTo(depositPosition) < deposit.radius) {
                                        isOnDirtDepositArea = true;
                                        break;
                                    }
                                }

                                if (isOnDirtDepositArea) {
                                    continue; // Pula esta interseção, pois está em uma área proibida
                                }

                                const hitNormal = intersects[i].face.normal.clone().transformDirection(intersectedObject.matrixWorld).normalize();
                                placementPosition.copy(hitPoint);
                                placementPosition.add(hitNormal.multiplyScalar(currentGhostHeight / 2));

                                const playerPos = new THREE.Vector3().copy(playerBody.position);
                                playerPos.y += currentPlayerRadius;

                                const distanceToPlayer = placementPosition.distanceTo(playerPos);
                                const minPlayerDistance = currentPlayerRadius + (currentGhostHeight / 2) + 0.1;

                                if (distanceToPlayer > minPlayerDistance) {
                                    canPlace = true;
                                    // Se for uma muda de árvore, verifica a distância das outras árvores (incluindo as adultas)
                                    if (currentBlockType === 'muda_arvore') {
                                        for (const existingBody of placedConstructionBodies) {
                                            // Verifica se o corpo existente é uma árvore em qualquer estágio de crescimento
                                            // (muda, media ou arvore_adulta)
                                            if (existingBody.userData.type === 'muda_arvore' || existingBody.userData.growthStage) {
                                                const existingTreePos = new THREE.Vector3().copy(existingBody.position);
                                                const distanceToExistingTree = placementPosition.distanceTo(existingTreePos);
                                                // AQUI: A regra para não colocar mudas perto de árvores grandes
                                                if (distanceToExistingTree < minTreePlacementDistance) {
                                                    canPlace = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (canPlace) break;
                                }
                            }
                        }
                    }
                    crosshairColor = canPlace ? 'lime' : 'red';
                } else if (isPrimaryToolApplyingTexture) {
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const groundMeshes = islandMeshes.map(item => item.mesh);
                    const intersects = raycaster.intersectObjects(groundMeshes, false);
                    let canApply = false;
                    if (intersects.length > 0) {
                        // Se houver qualquer interseção com o chão, podemos aplicar.
                        canApply = true;
                    }
                    crosshairColor = canApply ? 'lime' : 'white';
                } else if (isPrimaryToolDestroying) {
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(scene.children, true);
                    let canDestroy = false;
                    for (let i = 0; i < intersects.length; i++) {
                        if (intersects[i].distance > destroyDistance) continue;

                        let intersectedObject = intersects[i].object;

                        // Check for patches
                        if (intersectedObject.userData && intersectedObject.userData.isDestructible && intersectedObject.userData.type === 'patch') {
                            canDestroy = true;
                            break;
                        }

                        // Check for blocks with physics bodies
                        let intersectedBody = null;
                        let currentObject = intersectedObject;
                        while (currentObject) {
                            if (currentObject.userData && currentObject.userData.physicsBody) {
                                intersectedBody = currentObject.userData.physicsBody;
                                if (intersectedBody && intersectedBody.userData && intersectedBody.userData.isDestructible) {
                                    canDestroy = true;
                                }
                                break;
                            }
                            currentObject = currentObject.parent;
                        }

                        if (canDestroy) break;
                    }
                    crosshairColor = canDestroy ? 'red' : 'white';
                } else if (isPrimaryToolGrabbing) {
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(scene.children);
                    let objectInRange = false;
                    const aimablePickableBodies = collectibleBoxes.map(b => b.body);

                    for (let i = 0; i < intersects.length; i++) {
                        if (intersects[i].object.userData.physicsBody &&
                            aimablePickableBodies.includes(intersects[i].object.userData.physicsBody)) {
                            if (intersects[i].distance <= pickUpDistance) {
                                objectInRange = true;
                                break;
                            }
                        }
                    }
                    crosshairColor = objectInRange ? 'gold' : 'white';
                } else {
                    crosshairColor = 'white';
                }
            }
            crosshairElement.style.setProperty('--crosshair-color', crosshairColor);

            // Update ghostBlockMesh visibility and geometry
            if (ghostBlockMesh) {
                if (isPrimaryToolPlacing && !gamePaused) {
                    ghostBlockMesh.visible = true;
                    // Set color based on canPlace (which is determined by crosshair logic)
                    ghostBlockMesh.material.color.setHex(crosshairColor === 'lime' ? 0x00ff00 : 0xff0000);
                } else {
                    ghostBlockMesh.visible = false;
                }
            }

            // Update smoke particles
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const particle = smokeParticles[i];
                particle.userData.lifetime -= 1 / 60; // Assuming 60 FPS
                if (particle.userData.lifetime <= 0) {
                    scene.remove(particle);
                    smokeParticles.splice(i, 1);
                } else {
                    particle.position.add(particle.userData.velocity.clone().multiplyScalar(1 / 60));
                    particle.material.opacity = particle.userData.lifetime; // Fade out
                    particle.scale.addScalar(0.01); // Grow slightly
                }
            }

            // Renderiza a cena
            renderer.render(scene, camera);
            // Log para depuração: Mostra os corpos de construção colocados
            // console.log("Corpos de construção colocados (animate):", placedConstructionBodies.map(b => ({ id: b.id, type: b.userData.type, position: b.position })));
        }

        // Função para iniciar o jogo
        function startGame() {
            document.getElementById('startScreen').style.display = 'none'; // Oculta a tela inicial
            init(); // Inicializa os componentes do jogo
            window.dirtDeposits = dirtDeposits; // Expose for debug
            window.beltItems = beltItems;
            window.backpackItems = backpackItems; // Expor para teste
            window.updateBeltDisplay = updateBeltDisplay;
            window.updateBackpackDisplay = updateBackpackDisplay; // Expor para teste
            window.selectedSlotIndex = selectedSlotIndex;
            animate(); // Inicia o loop de animação
            // Remove a solicitação de bloqueio do ponteiro daqui. O usuário precisará clicar no canvas para ativá-lo.
            if (menuIconButton) {
                menuIconButton.style.display = 'flex'; // Mostra o botão do menu ao iniciar o jogo
            }
            if (inventoryBeltElement) {
                inventoryBeltElement.style.visibility = 'visible'; // Mostra o cinto de inventário ao iniciar o jogo
                inventoryBeltElement.style.opacity = '1';
            }
        }

        // Listener de evento para o botão "Jogar"
        document.getElementById('startButton').addEventListener('click', startGame);

        // Não há necessidade de window.onload aqui, pois startGame será chamado pelo clique do botão
    </script>
</body>
</html>
