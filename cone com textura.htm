<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Objeto 3D com Textura de Terra</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; }
        #container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            font-family: sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">Objeto 3D: Topo com Curvatura Esférica + Textura de Terra (Clique e Arraste para Rotacionar)</div>
    
    <!-- Carrega a biblioteca Three.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- 1. CONFIGURAÇÃO DA GEOMETRIA (Parâmetros do Usuário) ---
        const baseRadiusA = 1.2; // Raio da área do topo (Largura da depressão)
        const volcanoOuterRadiusAtTop = baseRadiusA;
        const volcanoOuterRadiusAtBottom = 1.2; // Lados verticais
        const volcanoHeight = 0.5; 
        const volcanoRadialSegments = 256; 
        // ...

        // --- 2. PARÂMETROS DA DEPRESSÃO EM FORMA DE BOLA ---
        const depthD = 0.49; // A profundidade da curva (quão fundo vai)
        const maxRoundingDepth = depthD; 
        const topY = volcanoHeight / 2;
        
        // --- 3. PARÂMETROS DA DEPRESSÃO ESFÉRICA ---
        const a_radius = baseRadiusA; // Raio da abertura (a)
        const d_depth = maxRoundingDepth; // Profundidade da calota (d)
        
        const R_sphere = (a_radius*a_radius + d_depth*d_depth) / (2 * d_depth);
        const y_center_sphere = topY - ( (d_depth*d_depth - a_radius*a_radius) / (2 * d_depth) );
        

        // --- 4. CONFIGURAÇÃO DA CENA THREE.JS ---
        let scene, camera, renderer, volcano;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function init() {
            const container = document.getElementById('container');
            
            // Cena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); 
            
            // Câmera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, volcanoHeight * 4, 3.5); 
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            // Adiciona luzes
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Aumentei a intensidade para a textura
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Aumentei a intensidade
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffaa00, 1); // Reduzi a intensidade da luz pontual
            pointLight.position.set(2, 2, -2);
            scene.add(pointLight);

            // --- CRIAÇÃO E MANIPULAÇÃO DA GEOMETRIA (MÉTODO LATHE) ---
            const points = [];
            const N_CURVE_SEGMENTS = 64; 
            const bottomY = -volcanoHeight / 2;

            points.push(new THREE.Vector2(0, bottomY));
            points.push(new THREE.Vector2(volcanoOuterRadiusAtBottom, bottomY));
            points.push(new THREE.Vector2(volcanoOuterRadiusAtTop, topY));

            for (let i = N_CURVE_SEGMENTS; i >= 0; i--) {
                const r = (i / N_CURVE_SEGMENTS) * a_radius;
                const y_esferico = y_center_sphere - Math.sqrt(R_sphere*R_sphere - r*r);
                points.push(new THREE.Vector2(r, y_esferico));
            }

            const geometry = new THREE.LatheGeometry(points, volcanoRadialSegments);

            // --- Carregamento e Aplicação da Textura ---
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(
                "https://dl.dropbox.com/scl/fi/42sa7tz724dwunu8imycm/textura-de-terra-2.png?rlkey=7hibzddcn7cco8jeolqada3ho&st=g3xejz0j&dl=0",
                function (tex) {
                    tex.wrapS = THREE.RepeatWrapping; // Repetir a textura horizontalmente
                    tex.wrapT = THREE.RepeatWrapping; // Repetir a textura verticalmente
                    tex.repeat.set(4, 4); // Quantas vezes a textura vai se repetir
                    // Após a textura carregar e configurar, criamos o material
                    createVolcanoMesh(geometry, tex);
                },
                undefined, // onProgress callback (opcional)
                function (err) {
                    console.error('Erro ao carregar a textura:', err);
                    // Em caso de erro, cria um material padrão
                    createVolcanoMesh(geometry, null);
                }
            );

            // Função para criar o mesh (movida para dentro do callback de carregamento da textura)
            function createVolcanoMesh(geo, loadedTexture) {
                let material;
                if (loadedTexture) {
                    material = new THREE.MeshStandardMaterial({
                        map: loadedTexture,
                        // Você pode adicionar outros mapas aqui se tiver (normalMap, roughnessMap, etc.)
                    });
                } else {
                    // Material padrão se a textura não carregar
                    material = new THREE.MeshStandardMaterial({
                        color: 0x8B4513, // Cor de terra substituta
                    });
                }
                volcano = new THREE.Mesh(geo, material);
                scene.add(volcano);
            }

            // Adiciona manipuladores de eventos de mouse para rotação
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mouseup', onMouseUp, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);
        }
        
        // --- FUNÇÕES DE INTERAÇÃO E RENDERIZAÇÃO ---
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onMouseMove(event) {
            if (!isDragging) return;
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            volcano.rotation.y += deltaX * 0.005;
            const newRotationX = volcano.rotation.x + deltaY * 0.005;
            if (newRotationX > -Math.PI / 2 && newRotationX < Math.PI / 2) {
                volcano.rotation.x = newRotationX;
            }

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        window.onload = function () {
            init();
            animate();
        }
    </script>
</body>
</html>